package is207.connectn.game;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;



/**
 * Base class for Strategy implementation. Strategy objects must keep
 * track of the game state, and select a move as a response to the
 * opponents last move.
 *
 * @author evenal
 */
public abstract class Strategy implements Callable<Integer> {

    String name;
    protected int cols;
    protected int rows;
    protected int nConn;
    protected int timeout;
    protected TimeUnit timeUnit;
    protected int selectedMove;
    protected int lastMove;
    protected ArrayList<Integer> validMoves;


    /**
     * setup() is called before the game starts, to inform the
     * strategy about the game configuration. This method is called to
     * provide the strategy with information. It can not be used to
     * change the game configuration
     *
     * @param params the game configuration
     */
    public void setup(GameParams params) {
        this.cols = params.getCols();
        this.rows = params.getRows();
        this.timeout = params.getTimeLimit();
        this.timeUnit = params.getTimeUnit();
        this.nConn = params.getConnLen();
    }


    /**
     * @return the total number of timeUnits available for selecting a
     *         move. NOTE: This is not the remaining time. It is the
     *         responsibility of the strategy to keep track of how
     *         much time is left.
     */
    public int getTimeout() {
        return timeout;
    }


    public TimeUnit getTimeUnit() {
        return timeUnit;
    }


    public String getName() {
        return name;
    }


    /**
     * Decide the next move. The move is the index of the column to
     * drop a disk in. The disk will drop to the lowest empty cell in
     * that column.
     *
     * @return the next move
     */
    public abstract Integer call();


    /**
     * This method allow the use of alternative strategies, or
     * iterative deepening. The game will call this method to get a
     * move if call() was interrupted. You should always update
     * selectedMove with the best move you have found so far, if you
     * think your algorithm may run out of time
     */
    public int getSelectedMove() {
        return selectedMove;
    }


    /**
     * Called from the game to inform the strategy about the opponents
     * mmove, and the moves that are available.
     *
     * @param lastMove the last move made by the opponent. The value
     *                 is the index of the column the opponent dropped
     *                 a disk into. If this strategy is deciding the
     *                 first move of the game, i.e. the opponent
     *                 hasn't made a move yet, the parameter value
     *                 will be -1
     *
     * @return the next move
     */
    public final void prepare(int lastMove, ArrayList<Integer> validMoves) {
        this.lastMove = lastMove;
        this.validMoves = validMoves;
     }

}
