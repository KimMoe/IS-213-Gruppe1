/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package is207.connectn.handin.eirik;

import is207.connectn.strategy.Strategy;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.Random;



/**
 *
 * @author eirik kvarstein
 *
 *
 */
public class EirikStrategyBackend extends Strategy
{

    /*
     * Fields
     */
    private Node[][] board;
    private Boolean ready = false;
    private Boolean network_disabled = false;
    //Node state's
    private final byte EMPTY = 0;
    private final byte MINE = 1;
    private final byte ENEMY = 2;
    private static Random rand = new Random();
    String gamecode = ""; // contains sequence of moves, uploaded to backend after game.
    private boolean turn_zero = false; // if we go first
    int player = 2; // player 1 or 2. ( is automaticly detected  -- must be 2 as default )

    //Settings
    private final int sensitivity = 3; //Disk Sensitivity, how long chains the bot will block/grab. ( 3 in a row ).

    /*
     * Constructor -- Setup
     */
    public EirikStrategyBackend() {

        //Setup() Has not been called yet..?
        // System.out.println("EirikStrategy ready as fuck!");
    }

    /*
     * Uploads game history to backend, called from ConnectNPanel.
     * author: eirik
     */
    /*
     * @Override
     * public void GameOver(String winloss){
     * //Upload gamecode to backend
     * String upload = "http://eirik.pw:3000/upload/" + winloss + "/"
     * + gamecode + "/" + player;
     *
     * int result = GET(upload);
     * if(result == 66){ // If upload fails, disable network
     * network_disabled = true;
     * }
     * }
     */
    /*
     * Send game history to server, and request move based on history
     */
    public int queryServer() {
        //Send request to backend, containing the gamecode
        //if return != 10, use it.
        if (gamecode.length() == 0)
            return 66;

        String url = "http://eirik.pw:3000/q/" + player + "/" + gamecode;
        //Check timer etc here.
        return GET(url);
    }

    /*
     * Setup nodelist etc after we have received the first call --
     * Setup() has been ran
     */
    public void init() {
        // super.setup(null);
        System.out.println("Created new nodelist: " + rows + "," + cols);
        board = new Node[rows][cols];

        //fill board with empty nodes
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                Node temp = new Node(EMPTY);
                board[i][j] = temp;
            }
        }

    }

    /*
     * Returns the position the disk will land in a given move.
     * @return int[2]. 0 = row, 1 = col
     *
     */
    int[] getBoardPos(int move) {

        // move = col
        //Figure out where the piece lands.
        //Loop throuigh colons, and check if the spot is occupied.
        //Start from the top
        // int landed_row = rows-1;
        int landed_row = 0;
        for (int i = rows - 1; i > -1; i--) { //Stats on cols-1, so only 0-5 is counted ( out of 6 )
            //System.out.println("Checking spot: "+i+","+move);
            //System.out.flush();

            landed_row = i;
            if (!board[landed_row][move].isEmpty()) { //We found another piece, so current landed one above.
                //System.out.println("Debug: Increasing "+landed_row);
                if (landed_row < rows - 1) //dont increase if we are at top of row ( 5)
                    landed_row++; //This piece landed above the other we found previously.
                //System.out.println("Above this piece. here it is: "+landed_row);
                break;
            }
        }
        int[] pos = new int[2];
        pos[0] = landed_row; //row
        pos[1] = move; //colon
        // System.out.println("Disk will land at: "+pos[0]+","+pos[1]);
        return pos;
    }

    //Helper functions
    //Check horizontal connections
    int horcon(int row, byte state) {
        int connected = 0;
        int max = 0;
        for (int i = 0; i < cols; i++) {
            if (board[row][i].isState(state)) {
                connected++;
                if (connected > max)
                    max = connected; //keep the longest chain of disks.
            }
            else {
                connected = 0; //gap in line, reset connected.
            }
        }
        return max;
    }

    /*
     * Check Vertical connections, checks connected discs starting
     * with the one under current position.
     */
    int vercon(int row, int col, byte state) {
        int connected = 0;
        int max = 0;
        Boolean connectedToThis = true;
        if (row > 2) {
            //Start at the pos below
            //Update: And ONLY check 3 places below
            for (int i = row - 1; i > row - 4; i--) {
                if (board[i][col].isState(state)) {
                    connected++;
                    if (connected > max)
                        max = connected;
                }
                else {
                    connected = 0;
                    connectedToThis = false;
                }
            }
        }
        if (!connectedToThis) connected = 0;
        return connected; //longest chain
    }

    /*
     * Check if opponent will win if he places a piece on this
     * position
     */
    private Boolean isCritical(int[] pos, byte state) {

        //Check vertical connections
        if (vercon(pos[0], pos[1], state) >= 3) return true;

        //Check Horizontal
        //Check entire row, pretending current spot to be taken by enemy
        board[pos[0]][pos[1]].setState(state); //temporary

        int test = horcon(pos[0], state);
        //System.out.println("Horizontal test: "+test);
        if (test > sensitivity) { //Important tweak number: >=3 Will grab/block chains with 2. >3 will only care about chains of 3.
            //Check if current position can change the connected number
            System.out.println("Warning state, found connection with >= 3");
            board[pos[0]][pos[1]].setState(EMPTY); //reset current pos
            if (state == ENEMY) { //If we are looking for chains to block.
                if (horcon(pos[0], state) < test) { //Check whole line again
                    System.out.println("Blocked");
                    return true; //If still connected, block it.
                }
            }
            else if (state == MINE) { //We are looking for spots to grab, lets see if it would benefit us.
                if (horcon(pos[0], state) < test) { //Check whole line again, check if connection would decrease..
                    System.out.println("Ninja grab!");
                    return true;
                }
            }
            else {
                //We are looking for chains of Empty spots, lets grab it.
                return true;
            }
        }

        board[pos[0]][pos[1]].setState(EMPTY); //Reset state, no danger.
        return false;
    }

    /*
     * Mark a spot as ours
     */
    void grab(int[] pos) {
        gamecode += selectedMove; //add our move to gamecode string
        board[pos[0]][pos[1]].setState(MINE);
    }

    @Override
    public Integer call() {

        /*
         * Prepare is called before every call(),
         * so check if we have initialized the first time
         */
        if (!ready) {
            init();
            ready = true;
        }

        if (lastMove > -1) { // If initial turn, this means enemy started
            turn_zero = false;
            gamecode += lastMove; //append move to gamecode string
            int[] pos = getBoardPos(lastMove);  //Calculate position on board the piece lands in.
            System.out.println("Enemy's piece landed in: " + pos[0] + "," + pos[1]);
            //Create node for enemy's play
            Node move = new Node(ENEMY);
            board[pos[0]][pos[1]] = move; //insert node into board
        }
        else {
            //We started first round, lastMove is not initialized.
            System.out.println("EirikStrat: I am player one");
            player = 1;
            turn_zero = true;
        }
        //System.out.println("State of node: "+board[pos[0]][pos[1]].toString());

       //Lets get down to business
        /*
         * Step One - Attempt to block points for the enemy
         */
        int[] current = new int[2];
        for (int i = 0; i < cols; i++) {
            if (validMoves.contains(i)) { // if that colon is valid
                selectedMove = i;
                current = getBoardPos(i);
                //Check if opponent will win if he places here
                if (isCritical(current, ENEMY)) { //check position that disk will land
                    System.out.println("EirikStrat: Go Go Gadget Fuckup: " + current[0] + "," + current[1]);
                    grab(current);
                    return i;
                }

            }

        }

        /*
         * Step Two - Query backend, check if we have played this
         * exact game before.
         */
        if (!network_disabled) {
            int res = queryServer();
            if (res != -1 && res != -2 && !turn_zero && !network_disabled) {
                System.out.println("** Using Move from Server: " + res);
                turn_zero = false;
                current = getBoardPos(res);
                selectedMove = res;
                grab(current); //Major flaw fixed! Forgot to count moves from server in gamecode.. Shit
                return res;
            }
            else if (res == -1) {
                //We do not have a record of this gamecode, disable network for rest of this round.
                network_disabled = true;
            }
            else if (res == -2) {
                //We have a loss record of this gamecode, do not use move from server, but do not disable network either.
                //To be able to emergency dodge if this state continues to the end of loss-receorded gamecode.
            }

        }

        /*
         * Step Three - See if we can grab some easy points
         */
        for (int i = 0; i < cols; i++) {
            if (validMoves.contains(i)) {
                current = getBoardPos(i); //Wow. forgot this.
                if (isCritical(current, MINE)) {
                    System.out.println("EirikStrat: Grabbing this " + current[0] + "," + current[1]);
                    selectedMove = i;
                    grab(current);
                    return i;
                }
            }
        }

        //If we get here, no alternative is critical for enemy or for myself.
        //Check if a chain of empty spots exists, and grab some of them to fuckup for the enemy
        // If we still have time? @TODO: Check time
        /*
         * for(int i=0;i<cols;i++){
         * if(validMoves.contains(i)){
         * current = getBoardPos(i);
         * if(isCritical(current, EMPTY)){
         * //Hm. What could happen
         * System.out.println("Experimental: Blocking Empty chain");
         * selectedMove = i;
         * grab(current);
         * return i;
         * }
         * }
         * }
         */
        //If we get here, just grab random i guess.
        int rnd = rand.nextInt(validMoves.size());
        selectedMove = validMoves.get(rnd);
        grab(getBoardPos(selectedMove));
        return selectedMove;

    }

    /*
     * Contains info on a particular position in the board
     * @param state - EMPTY, MINE or ENEMY
     */


    class Node
    {
        //int col,row;
        private byte state = 0;

        public Node(byte state) {
            this.state = state;
        }

        public Boolean isEmpty() {
            return state == EMPTY;
        }

        public Boolean isEnemy() {
            return state == ENEMY;
        }

        public Boolean isState(byte state) {
            return this.state == state;
        }

        public void setState(byte state) {
            this.state = state;
        }

        @Override
        public String toString() {
            String res = "";
            switch (state) {
            case EMPTY:
                res = "Node is EMPTY";
                break;
            case MINE:
                res = "Node is MINE";
                break;
            case ENEMY:
                res = "Node is ENEMY's";
                break;
            default:
                res = "Something is horribly wrong";
                break;

            }
            return res;
        }
    }

    /*
     * Network Functions
     */
    /*
     * Send HTTP Get request and catch response
     */
    public int GET(String urlstr) {
        String response = "";
        int code = 66;
        try {
            URL url = new URL(urlstr);
            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
            while (null != (response = br.readLine())) {
                // Attempt to parse Integer out of string response
                code = Integer.parseInt(response);
                response = response.trim(); //add string terminator
                System.out.println("Server: " + response);
            }

        }
        catch (IOException | NumberFormatException ex) {
            network_disabled = true;
            System.out.println("Exception in GET: " + ex.getMessage());
            //Disable network
            network_disabled = true;

            ex.printStackTrace();
            return 66;

        }

        return code;
    }

}
