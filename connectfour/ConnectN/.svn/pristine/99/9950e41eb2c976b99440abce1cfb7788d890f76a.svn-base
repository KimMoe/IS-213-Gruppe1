package is207.connectn.handin.others;

import is207.connectn.game.GameParams;
import is207.connectn.strategy.Strategy;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Random;
import java.util.Scanner;



public class MinimaxStrategy extends Strategy
{

    private final EvalResult MIN_RESULT = new EvalResult(Integer.MIN_VALUE);
    private final EvalResult MAX_RESULT = new EvalResult(Integer.MAX_VALUE);
    private static final int FREE = 0;
    private static final int ME = 1;
    private static final int OPPONENT = -1;
    private static final int MAX_DEPTH = 5;

    Random random = new Random();

    Board board;
    Evaluator evaluator;

    public void setup(GameParams params) {
        super.setup(params);
        board = new Board();
        evaluator = new Evaluator();
    }

    public Integer call() {
        if (lastMove >= 0)
            board.add(lastMove, OPPONENT);

        EvalResult result = minimax(MAX_DEPTH, ME, new ArrayList<>());
        selectedMove = result.path.get(result.path.size() - 1);
        return selectedMove;
    }

    public EvalResult minimax(int depth,
                              int player,
                              ArrayList<Integer> path) {

        if (depth == 0) {
            return new EvalResult(evaluator.eval());
        }

        ArrayList<Integer> moves = new ArrayList<>();
        for (int c = 0; c < 6; ++c) {
            if (board.h[c] < rows)
                moves.add(c);
        }
        if (depth == 0) {
            return new EvalResult(evaluator.eval());
        }

        for (int c = 0; c < 1; ++c) {
            if (board.h[c] < rows)
                moves.add(c);
        }

        if (moves.size() == 0)
            return new EvalResult(0);

        EvalResult bestResult = MIN_RESULT;

        return bestResult;
    }



    private class EvalResult
    {

        int value;
        ArrayList<Integer> path;

        public EvalResult(int value) {
            this.value = value;
            path = new ArrayList<>();
        }

        public void print(int d) {
            for (int i = 0; i < MAX_DEPTH - d; i++)
                System.out.print("  ");
            for (int m : path)
                System.out.print(m + " ");
            System.out.println(" scores " + value);
            System.out.flush();
        }
    }



    private class Board
    {

        int[][] state;
        int[] h;
        LinkedList<Integer> moveStack;

        public Board() {
            moveStack = new LinkedList<>();
            h = new int[cols];
            state = new int[rows][cols];
            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols; c++) {
                    state[r][c] = 0;
                    h[c] = 0;
                }
        }

        public void add(int move, int player) {
            moveStack.addFirst(move);
            int c = move;
            int r = h[c];
            state[r][c] = player;
            h[c] = r + 1;
        }

        public void undo() {
            int c = moveStack.removeFirst();
            h[c]--;
            state[h[c]][c] = 0;
        }

        public void printState() {
            System.out.print("+");
            for (int col = 0; col < cols; col++)
                System.out.print("-");
            System.out.println("+");
            for (int row = rows - 1; row >= 0; row--) {
                System.out.print("|");
                for (int col = 0; col < cols; col++) {
                    if (state[row][col] == 1)
                        System.out.print("O");
                    else if (state[row][col] == -1)
                        System.out.print("X");
                    else if (state[row][col] == 0)
                        System.out.print(".");
                    else
                        System.out.print("?");
                }
                System.out.println("|");
            }
            System.out.print("+");
            for (int col = 0; col < cols; col++)
                System.out.print("-");
            System.out.println("+");
            System.out.flush();
        }

    }



    private class Evaluator
    {

        int[] myOpportunities = new int[3];
        int[] oppOpportunities = new int[3];

        int mine, opps, free;

        public Evaluator() {
        }

        public int eval() {

            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r][c + i]);
                    analyzeCounts();
                }

            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c]);
                    analyzeCounts();
                }

            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c + i]);
                    analyzeCounts();
                }
            for (int r = rows - 1; r >= nConn - 1; r--)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++) {
                        int ri = r - i;
                        int ci = c + i;
                        count(board.state[ri][ci]);
                    }
                    analyzeCounts();
                }

            int retval = 0;
            for (int i = 0; i < 3; i++) {
                retval = 10 * retval
                        + myOpportunities[i]
                        - oppOpportunities[i];
            }

            return retval;
        }

        private void count(int cellVal) {
            switch (cellVal) {
            case ME:
                mine++;
                break;
            case OPPONENT:
                opps++;
                break;
            case FREE:
                free++;
                break;
            }
        }

        private void analyzeCounts() {
            for (int i = 0; i < 3; i++) {
                if (free == i && opps == nConn - i) {
                    oppOpportunities[i]++;
                }
                if (free == i && mine == nConn - i) {
                    myOpportunities[i]++;
                }
            }
        }
    }

    public static void main(String[] args) {

        MinimaxStrategy strat = new MinimaxStrategy();
        strat.setup(new GameParams());
        Scanner in = new Scanner(System.in);

        while (true) {
            System.out.print("Move: ");
            int move = in.nextInt();
            if (move < 0)
                System.exit(0);
            System.out.println("you chose " + move);

            strat.prepare(move, null);
            strat.call();
            System.out.println("Computer chose " + strat.getSelectedMove());
        }
    }
}
