package is207.connectn.handin.olepetter;

import is207.connectn.game.GameParams;
import is207.connectn.strategy.Strategy;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Random;
import java.util.Scanner;



/**
 * Fors�k p� alpha/beta pruning. For det meste det samme som negamax,
 * hopp til linje 92 for endringer. Copypaste til StrategyManager:
 * register("AlphaBeta", AlphaBeta.class);
 */
public class AlphaBeta extends Strategy
{

    private final EvalResult MIN_RESULT = new EvalResult(Integer.MIN_VALUE);
    private static final int FREE = 0;
    private static final int ME = 1;
    private static final int OPPONENT = -1;
    private static final int MAX_DEPTH = 5;
    private static final int BETA = Integer.MAX_VALUE;
    private static final int ALPHA = Integer.MIN_VALUE;

    Random random = new Random();

    Board board;
    Evaluator evaluator;

    public void setup(GameParams params) {
        super.setup(params);
        board = new Board();
        evaluator = new Evaluator();
    }

    public Integer call() {
        if (lastMove >= 0)
            board.add(lastMove, OPPONENT);

        EvalResult result = alphabeta(MAX_DEPTH, ME, ALPHA, BETA, new ArrayList<>());
        selectedMove = result.path.get(result.path.size() - 1);
        return selectedMove;
    }

    public EvalResult alphabeta(int depth,
                                int player,
                                int alpha,
                                int beta,
                                ArrayList<Object> arrayList) {
        int localalpha = alpha;

        if (depth == 0) {
            return new EvalResult(evaluator.eval());
        }

        ArrayList<Integer> moves = new ArrayList<>();
        for (int c = 0; c < cols; c++) {
            if (board.h[c] < rows)
                moves.add(c);
        }
        // if no available moves, the board is full which is a draw
        // no need to analyze
        if (moves.size() == 0)
            return new EvalResult(0);

        EvalResult bestResult = MIN_RESULT;
        // shuffle moves to make the strategy less predictable
        ArrayList<Integer> shuffledMoves = new ArrayList<>(moves);
        for (int to = 0; to < shuffledMoves.size(); to++) {
            int from = random.nextInt(shuffledMoves.size());
            int tmp = shuffledMoves.get(to);
            shuffledMoves.set(to, shuffledMoves.get(from));
            shuffledMoves.set(from, tmp);
        }

//        // debug print
//        String prefix = new String
//        System.out.print("path(" + path.size() + "):");
//        for (int m : path)
//            System.out.print(" " + m);
//        System.out.println("\nMove\tValue");
//        // end debug print
        for (int c : shuffledMoves) {
            board.add(c, player);
            arrayList.add(c);

            EvalResult result = alphabeta(depth - 1, -player, +localalpha, +beta, arrayList);
            result.print(depth);

            if (result.value >= bestResult.value) {
                bestResult = result;
                bestResult.value = -bestResult.value;
                bestResult.path.add(c);
                if (bestResult.value >= beta) {
                    break;
                }
                else if (bestResult.value > localalpha) {
                    localalpha = bestResult.value;
                }
            }

            board.undo();
            arrayList.remove(arrayList.size() - 1);
        }
        return bestResult;
    }



    private class EvalResult
    {

        int value;
        ArrayList<Integer> path;

        public EvalResult(int value) {
            this.value = value;
            path = new ArrayList<>();
        }

        public void print(int d) {
            for (int i = 0; i < MAX_DEPTH - d; i++)
                System.out.print("  ");
            for (int m : path)
                System.out.print(m + " ");
            System.out.println(" scores " + value);
            System.out.flush();
        }
    }



    private class Board
    {

        int[][] state;
        int[] h;
        LinkedList<Integer> moveStack;

        public Board() {
            moveStack = new LinkedList<>();
            h = new int[cols];
            state = new int[rows][cols];
            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols; c++) {
                    state[r][c] = 0;
                    h[c] = 0;
                }
        }

        public void add(int move, int player) {
            moveStack.addFirst(move);
            int c = move;
            int r = h[c];
            state[r][c] = player;
            h[c] = r + 1;
        }

        public void undo() {
            int c = moveStack.removeFirst();
            h[c]--;
            state[h[c]][c] = 0;
        }

//        public void printState() {
//            System.out.print("+");
//            for (int col = 0; col < cols; col++)
//                System.out.print("-");
//            System.out.println("+");
//            for (int row = rows - 1; row >= 0; row--) {
//                System.out.print("|");
//                for (int col = 0; col < cols; col++) {
//                    if (state[row][col] == 1)
//                        System.out.print("O");
//                    else if (state[row][col] == -1)
//                        System.out.print("X");
//                    else if (state[row][col] == 0)
//                        System.out.print(".");
//                    else
//                        System.out.print("?");
//                }
//                System.out.println("|");
//            }
//            System.out.print("+");
//            for (int col = 0; col < cols; col++)
//                System.out.print("-");
//            System.out.println("+");
//            System.out.flush();
//        }
    }



    private class Evaluator
    {

        // summary of the situation - the number of places where
        // arrayindex pieces are missing to win
        int[] myOpportunities = new int[3];
        int[] oppOpportunities = new int[3];

        // disk counts
        int mine, opps, free;

        public Evaluator() {
        }

        public int eval() {
            // check for horizontal lines
            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r][c + i]);
                    analyzeCounts();
                }

            // check for vertical  lines
            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c]);
                    analyzeCounts();
                }

            // check for diagonal  lines
            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c + i]);
                    analyzeCounts();
                }
            for (int r = rows - 1; r >= nConn - 1; r--)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++) {
                        int ri = r - i;
                        int ci = c + i;
                        count(board.state[ri][ci]);
                    }
                    analyzeCounts();
                }

            int retval = 0;
            for (int i = 0; i < 3; i++) {
                retval = 10 * retval
                        + myOpportunities[i]
                        - oppOpportunities[i];
            }

//            // opponent has n in line - opponent wins
//            if (oppOpportunities[0] > 0)
//                retval = -100;
//            // I have n in line - I win
//            else if (myOpportunities[0] > 0)
//                retval = 100;
//            // opponent has multiple lines missing only one piece,
//            // almost certain win for the opponent
//            else if (oppOpportunities[1] > 1)
//                retval = -((40 * oppOpportunities[1]) % 100);
//            else if (myOpportunities[1] > 1)
//                retval = -((40 * myOpportunities[1]) % 100);
            /**
             * // opponent has multiple lines missing only two
             * pieces, // opponent will most likely win else if
             * (oppOpportunities[2] > 3) retval = -((20 *
             * oppOpportunities[2]) % 100); else if
             * (myOpportunities[2] > 3) retval = -((20 *
             * oppOpportunities[2]) % 100); // opponent is missing one
             * piece to win - with luck else if (oppOpportunities[1] >
             * 0) retval = -((40 * oppOpportunities[1]) % 100); else
             * if (myOpportunities[1] > 0) retval = -((40 *
             * myOpportunities[1]) % 100);
             */
            return retval;
        }

        private void count(int cellVal) {
            switch (cellVal) {
            case ME:
                mine++;
                break;
            case OPPONENT:
                opps++;
                break;
            case FREE:
                free++;
                break;
            }
        }

        /**
         * Check if the game is one, or if the player is missing only
         * one or two pieces to win. The result is added to the
         * opportunities arrays
         */
        private void analyzeCounts() {
            for (int i = 0; i < 3; i++) {
                if (free == i && opps == nConn - i) {
                    oppOpportunities[i]++;
                }
                if (free == i && mine == nConn - i) {
                    myOpportunities[i]++;
                }
            }
        }
    }

    public static void main(String[] args) {

        AlphaBeta strat = new AlphaBeta();
        strat.setup(new GameParams());
        Scanner in = new Scanner(System.in);

        while (true) {
            System.out.print("Move: ");
            int move = in.nextInt();
            if (move < 0)
                System.exit(0);
            System.out.println("you chose " + move);

            strat.prepare(move, null);
            strat.call();
            System.out.println("Computer chose " + strat.getSelectedMove());
        }
    }
}
