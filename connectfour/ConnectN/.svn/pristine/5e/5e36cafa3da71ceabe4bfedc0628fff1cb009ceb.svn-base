package is207.connectn.game.strategy.minimax;

import is207.connectn.game.GameParams;
import is207.connectn.game.strategy.Strategy;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * This is NegaMax with alpha-beta pruning
 *
 * @author evenal
 */
public class NegaScout extends Strategy
{

    private static final int ME = 1;
    private static final int HIM = -1;
    Board board;
    int lookAhead = 0;

    @Override
    public void setup(GameParams params) {
        super.setup(params);
        board = new Board(rows, cols);
        selectedMove = lastMove = -1;
    }

    @Override
    public Integer call() {
        // update board
        if (selectedMove >= 0) {
            board.doMove(selectedMove, ME);
        }
        if (lastMove >= 0) {
            board.doMove(lastMove, HIM);
        }

        for (lookAhead = 3; lookAhead < 10; lookAhead++) {
            Result res = negaScout(ME, lookAhead,
                    Integer.MIN_VALUE, Integer.MAX_VALUE);
            selectedMove = res.move;
        }
        return selectedMove;
    }

    private Result negaScout(int player, int depth,
                             int alpha, int beta) {
        if (depth == 0) {
            return new Result(-1, player * eval());
        }

        int bestValue = Integer.MIN_VALUE;
        int bestMove = -1;
        ArrayList<Integer> moves = board.getLegalMoves();
        if (moves.isEmpty()) {
            return new Result(-1, player * eval());
        }

        for (int m : moves) {
            board.doMove(m, player);
            if (connectedN(player, board.h[m] - 1, m)) {
                bestMove = m;
                bestValue = 1000;
            }
            Result res = negaScout(-player, depth - 1, -beta, -alpha);
            int val = -res.value;
            if (val > bestValue) {
                bestValue = val;
                bestMove = m;
            }
            board.undoMove();
            if (val > alpha) {
                alpha = val;
                if (alpha > beta) {
                    break;
                }
            }
        }
        return new Result(bestMove, bestValue);

    }

    private boolean connectedN(int p, int r, int c) {
        assert board.state[r][c] == p;

        return connected(p, r, c, 0, 1) || connected(p, r, c, 1, 1);
    }

    private boolean connected(int p, int r, int c, int dr, int dc) {
        for (int i = 1; i < nConn; i++) {
            int ir = r + i * dr;
            int ic = c + i * dc;

            if (ir >= rows) return false;
            if (ir < 0) return false;
            if (ic >= cols) return false;
            if (ic < 0) return false;
            if (board.state[ir][ic] != p) return false;
        }
        return true;
    }

    private int eval() {
        int myPoints = 0;
        int oppPoints = 0;

        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                myPoints += countPts(r, c, ME);
                oppPoints += countPts(r, c, HIM);
            }
        }
        board.logState("Eval -> ", myPoints - oppPoints);
        return myPoints - oppPoints;
    }

    private int countPts(int r, int c, int player) {
        if (board.state[r][c] != ME) {
            return 0;
        }
        int sum = countPts(r, c, player, 1, 0);
        sum += countPts(r, c, player, 1, 1);
        sum += countPts(r, c, player, 0, 1);
        sum += countPts(r, c, player, -1, 1);
        sum += countPts(r, c, player, -1, 0);
        sum += countPts(r, c, player, -1, -1);
        sum += countPts(r, c, player, 0, -1);
        sum += countPts(r, c, player, 1, -1);
        return sum;
    }

    private int countPts(int r, int c, int p, int dr, int dc) {
        int seq = 0;
        int total = 0;
        boolean broken = false;

        for (int i = 0; i < nConn; i++) {
            int tr = r + i * dr;
            int tc = c + i * dc;
            if (tr >= 0 && tr < rows && tc >= 0 && tc < cols) {
                int v = board.state[r + i * dr][c + i * dc];
                if (v == p) {
                    total++;
                    if (!broken) {
                        seq++;
                    }
                }
                else if (v == 0) {
                    broken = true;
                }
                else {
                    return 0;
                }
            }
        }
        if (seq == nConn) {
            return 1000;
        }
        else if (seq == nConn - 1) {
            return 100;
        }
        else {
            return total;
        }
    }

    private class Result
    {

        public int move;
        public int value;

        public Result(int move, int value) {
            this.move = move;
            this.value = value;
        }
    }

    public static void main(String[] args) {

        NegaScout strat = new NegaScout();
        strat.setup(new GameParams());
        Scanner in = new Scanner(System.in);

        while (true) {
            System.out.print("Move: ");
            int move = in.nextInt();
            if (move < 0) {
                System.exit(0);
            }
            System.out.println("you chose " + move);

            strat.prepare(move, null);
            strat.call();
            System.out.println("Computer chose " + strat.getSelectedMove());
        }
    }
}
