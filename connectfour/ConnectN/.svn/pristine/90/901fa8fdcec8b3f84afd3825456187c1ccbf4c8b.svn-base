package is207.connectn.game.strategy.minimax;

import is207.connectn.game.GameParams;
import is207.connectn.game.Strategy;
import java.util.ArrayList;
import java.util.LinkedList;



/**
 *
 * @author evenal
 */
public class NegaMaxStrategy extends Strategy {

    private final EvalResult MIN_RESULT = new EvalResult(Integer.MIN_VALUE);
    private static final int FREE = 0;
    private static final int ME = 1;
    private static final int OPPONENT = -1;

    Board board;
    Evaluator evaluator;


    public void setup(GameParams params) {
        super.setup(params);
        board = new Board();
        evaluator = new Evaluator();
    }


    public Integer call() {
        board.add(lastMove, OPPONENT);

        return selectedMove;
    }


    public EvalResult negamax(int depth,
                              int player,
                              ArrayList<Integer> path) {
        if (depth == 0) {
            return new EvalResult(evaluator.eval());
        }

        ArrayList<Integer> moves = new ArrayList<>();
        for (int c = 0; c < cols; c++) {
            if (board.h[c] < rows)
                moves.add(c);
        }
        // if no available moves, the board is full which is a draw
        // no need to analyze
        if (moves.size() == 0)
            return new EvalResult(0);

        EvalResult bestResult = MIN_RESULT;
        for (int c : moves) {
            board.add(c, player);
            EvalResult result = negamax(depth - 1, -player, path);
            if (result.value > bestResult.value) {
                bestResult = result;
                bestResult.value = -bestResult.value;
                bestResult.path.add(c);
            }
            board.undo();
        }
        return bestResult;
    }



    private class EvalResult {

        int value;
        ArrayList<Integer> path;


        public EvalResult(int value) {
            this.value = value;
            path = new ArrayList<>();
        }
    }



    private class Board {

        int[][] state;
        int[] h;
        LinkedList<Integer> moveStack;


        public Board() {
            moveStack = new LinkedList<>();
            h = new int[cols];
            state = new int[rows][cols];
            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols; c++) {
                    state[r][c] = 0;
                    h[c] = 0;
                }
        }


        public void add(int move, int player) {
            moveStack.addFirst(move);
            int c = move;
            int r = h[c];
            state[r][c] = player;
            h[c] = r + 1;
        }


        public void undo() {
            int c = moveStack.removeFirst();
            h[c]--;
            state[h[c]][c] = 0;
        }
    }



    private class Evaluator {

        Board board;
        // summary of the situation - the number of places where
        // arrayindex pieces are missing to win
        int[] myOpportunities = new int[3];
        int[] oppOpportunities = new int[3];

        // disk counts
        int mine, opps, free;


        public Evaluator() {
        }


        public int eval() {
            // check for horizontal lines
            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r][c + i]);
                    analyzeCounts();
                }

            // check for vertical  lines
            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c]);
                    analyzeCounts();
                }

            // check for diagonal  lines
            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c + i]);
                    analyzeCounts();
                }
            for (int r = rows - 1; r >= nConn - 1; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r - i][c + i]);
                    analyzeCounts();
                }

            // opponent has n in line - opponent wins
            if (oppOpportunities[0] > 0)
                return -100;
            // I have n in line - I win
            else if (myOpportunities[0] > 0)
                return 100;
            // opponent has multiple lines missing only one piece,
            // almost certain win for the opponent
            else if (oppOpportunities[1] > 1)
                return -((40 * oppOpportunities[1]) % 100);
            else if (myOpportunities[1] > 1)
                return -((40 * myOpportunities[1]) % 100);
            // opponent has multiple lines missing only two pieces,
            // opponent will most likely win
            else if (oppOpportunities[2] > 3)
                return -((20 * oppOpportunities[2]) % 100);
            else if (myOpportunities[2] > 3)
                return -((20 * oppOpportunities[2]) % 100);
            // opponent is missing one piece to win - with luck
            else if (oppOpportunities[1] > 0)
                return -((40 * oppOpportunities[1]) % 100);
            else if (myOpportunities[1] > 0)
                return -((40 * myOpportunities[1]) % 100);
            else
                return 0;
        }


        private void count(int cellVal) {
            switch (cellVal) {
            case ME:
                mine++;
                break;
            case OPPONENT:
                opps++;
                break;
            case FREE:
                free++;
                break;
            }
        }


        /**
         * Check if the game is one, or if the player is missing only
         * one or two pieces to win. The result is added to the
         * opportunities arrays
         */
        private void analyzeCounts() {
            for (int i = 0;
                    i < 3; i++) {
                if (free == i && opps == nConn - i) {
                    oppOpportunities[i]++;
                }
                if (free == i && mine == nConn - i) {
                    myOpportunities[i]++;
                }
            }
        }
    }
}
