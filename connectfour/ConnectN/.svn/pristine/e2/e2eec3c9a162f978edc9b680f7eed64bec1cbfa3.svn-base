package is207.connectn.strategy;

import is207.connectn.strategy.Board.StackNode;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;



/**
 *
 * @author evenal
 */
public class NegaScout2 extends Strategy
{

    public static final int US = 1;
    public static final int THEM = -1;
    public static final int MAX_DEPTH = 5;
    public static final int MIN_VALUE = Integer.MIN_VALUE;
    public static final int ALPHA = Integer.MIN_VALUE;
    public static final int BETA = Integer.MAX_VALUE;
    public static final int[] LOOK_AHEADS = {
        3, 5, 9, 15, 23
    };

    private int[] priCols;
    Board state;

    @Override
    public void setup() {
        super.setup();
        state = new Board(rows, cols);
        selectedMove = -1;
    }

    @Override
    public Integer call() {
        if (selectedMove > -1) state.tryMove(selectedMove, US);
        if (lastMove > -1) state.tryMove(lastMove, THEM);
        int bestMove = 0;
        int bestVal = MIN_VALUE;

        for (int lookAhead : LOOK_AHEADS) {
            System.out.println("Lookahead = " + lookAhead + " moves");
            LinkedList<Integer> path = new LinkedList<>();
            List<Integer> validMoves = state.getLegalMoves();
            for (int i = 0; i < validMoves.size(); i++) {
                if (validMoves.get(i) == bestMove) {
                    validMoves.set(i, validMoves.get(0));
                    validMoves.set(0, bestMove);
                    break;
                }
            }
            for (int m : validMoves) {
                path.addLast(m);
                state.tryMove(m, US);
                int val = -negaScout(path, MAX_DEPTH, THEM, ALPHA, BETA);
//            System.out.println("\n  Move " + m + " value " + val);
//            state.logState("Val ", val);
                state.undoMove();
                path.removeLast();
                if (val > bestVal) {
                    bestMove = m;
                    bestVal = val;
                }
            }
            selectedMove = bestMove;
            System.out.println("Best move is " + bestMove + " (" + bestVal);
        }
        assert validMoves.contains(selectedMove);
        return bestMove;
    }

    /**
     * Plain minimax search up to MAX_DEPTH moves ahead,
     * implemented as negamax to save a few lines of codes.
     *
     * @param path the moves made to reach this situation
     * @param depth recursion depth counter, counts down from
     * MAX_DEPTH.
     * @param player 1 (US) if the current player is the maximizing
     * player, or -1 (THEM) if it is the minimizing player
     *
     * @return the value of the current situations
     */
    private int negaMax(LinkedList<Integer> path, int depth, int player) {
        int retVal = MIN_VALUE;
        assert path.size() + depth == MAX_DEPTH + 1;
        int move = path.getLast();
        List<Integer> validMoves = state.getLegalMoves();
        // checking for game over
        if (haveWon(move, -player)) { // the other player won
            return player * 10000;
        }
        else if (validMoves.isEmpty()) { // or draw
            return 0;
        }
        else if (depth == 0) { // bottom of recursion
            return player * evalState();
        }
        else {
            for (int m : validMoves) {
                path.addLast(m);
                state.tryMove(m, player);
                int val = -negaMax(path, depth - 1, -player);
                state.undoMove();
                path.removeLast();
                if (val > retVal) {
                    retVal = val;
                }
            }

        }
        return retVal;
    }

    /**
     * NegaMax with alpha beta pruning
     *
     * @param path the moves made to reach this situation
     * @param depth recursion depth counter, counts down from
     * MAX_DEPTH.
     * @param player 1 (US) if the current player is the maximizing
     * player, or -1 (THEM) if it is the minimizing player
     * @param alpha
     * @param beta
     *
     * @return
     */
    private int negaScout(LinkedList<Integer> path, int depth,
                          int player, int alpha, int beta) {
        int retVal = MIN_VALUE;
        assert path.size() + depth == MAX_DEPTH + 1;
        int move = path.getLast();
        List<Integer> validMoves = state.getLegalMoves();
        // checking for game over
        if (haveWon(move, -player)) { // the other player won
            return player * 10000;
        }
        else if (validMoves.isEmpty()) { // or draw
            return 0;
        }
        else if (depth == 0) { // bottom of recursion
            return player * evalState();
        }
        else {
            for (int m : validMoves) {
                path.addLast(m);
                state.tryMove(m, player);
                int val = -negaScout(path, depth - 1, -player,
                                     -beta, -alpha);
                state.undoMove();
                path.removeLast();
                if (val > retVal) {
                    retVal = val;
                    if (retVal > alpha) {
                        alpha = retVal;
                    }
                }
                if (alpha >= beta) {
                    break;
                }
            }
        }
        return retVal;
    }

    /**
     * Quick eval, returns true if the last move connected n pieces
     */
    private boolean haveWon(int move, int player) {
//        System.out.println("haveWon(" + move + ", " + player + ")");
        StackNode sn = state.moveStack.getFirst();
        state.printStack();
        assert move == sn.col;
        assert state.state[sn.row][sn.col] == player;

        return connected(sn, 1, 0)
                || connected(sn, 1, 1)
                || connected(sn, 0, 1)
                || connected(sn, -1, 1)
                || connected(sn, -1, 0)
                || connected(sn, -1, -1)
                || connected(sn, 0, -1)
                || connected(sn, 1, -1);

    }

    private boolean connected(StackNode sn, int dr, int dc) {
        for (int i = 1; i < nConn; i++) {
            int r = sn.row + i * dr;
            int c = sn.col + i * dc;
            if (r < 0) return false;
            if (r >= rows) return false;
            if (c < 0) return false;
            if (c >= cols) return false;
            if (state.state[r][c] != sn.player) return false;
        }
        return true;
    }

    private int evalState() {
        int points = 0;
        for (int r = 0; r < rows; r++)
            for (int c = 0; c < cols; c++) {
                points += count(r, c, 1, 0);
                points += count(r, c, 1, 1);
                points += count(r, c, 0, 1);
                points += count(r, c, -1, 1);
                points += count(r, c, -1, 0);
                points += count(r, c, -1, -1);
                points += count(r, c, 0, -1);
                points += count(r, c, 1, -1);
            }
        return points;
    }

    private int count(int r, int c, int dr, int dc) {
        int p = state.state[r][c];

        for (int i = 1; i < nConn; i++) {
            int r2 = r + i * dr;
            int c2 = c + i * dc;
            if (r2 < 0 || r2 >= rows || c2 < 0 || c2 >= cols
                    || state.state[r][c] != p) {
                switch (nConn - i) {
                case 1:
                    return p * (100 - 10 * Math.abs(c2 - cols / 2));
                case 2:
                    return p * (10 - Math.abs(c2 - cols / 2));
                }
            }
        }
        return p * 1000;
    }

    public static void main(String[] args) {
        NegaScout2 ns = new NegaScout2();
        ns.setup();
        Scanner in = new Scanner(System.in);

        while (true) {
            System.out.print("Move: ");
            int move = in.nextInt();
            if (move < 0)
                System.exit(0);
            System.out.println("you chose " + move);

            ns.prepare(move, null);
            ns.call();
            System.out.println("Computer chose " + ns.getSelectedMove());
        }
    }
}
