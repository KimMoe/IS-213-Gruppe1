package connectN.ctN;

import connectN.players.*;

import java.io.*;
import java.awt.*;
import java.awt.geom.*;
import java.awt.event.*;
import javax.swing.*;

public class ConnectNGame
{
    private final String defaultPlayer = "connectN.players.RandomPlayer";

    // The top-level GUI object.
    private  ConnectNGUI gui;
	private setUp setting; 

    // State that is transient durina a game.
    private final int STATE_PAUSED = 1;
    private final int STATE_PLAYING = 2;
    private final int STATE_MATCHOVER = 3;
    private int state;
    private int prevMoveCol;
    private int gameNum;
    private int moveNum;
    private int whoseTurn;

    // State that is permanent throughout a game but transient
    // during a match.
    private ConnectNBoard startingBoard;
    private ConnectNBoard board;
    private Player p1, p2;
    private String p1HumanName, p2HumanName;
    private String p1ClassFileName, p2ClassFileName;

    // State that is permanent throughout a match.
    private int numGames;
    private int numSeedMoves;
    private int rows, cols;
    private int msecPerMove;
    private String game;
    private int p1GamesWon, p2GamesWon;
    private int p1Points, p2Points;
	private int consecutivePieces;  

	/**
	 * @param rows Number of rows of the board
	 * @param cols Number of columns of the board
	 * @param consecutivePieces Number of consecutive connected slots for a win line  
	 * @param game Which game to play: "first" - First Connect-4 wins
	 *                                 "most" - Most Connect-4s wins
	 * @param msecPerMove Time allowed per move (msec)
	 * @param numGames Number of games
	 * @param numRandMoves Number of random moves, even, >=0, <=rows*cols
	 * @param p1ClassFileName Class name for player 1
	 * @param p2ClassFileName Class name for player 2
	 */
    public ConnectNGame (
        int rows, int cols,
        String game, int msecPerMove, int numGames, int numRandMoves,
        String p1ClassFileName, String p2ClassFileName, int consecutivePieces) 
        throws Exception {

        this.rows = rows;
        this.cols = cols;
		this.consecutivePieces = consecutivePieces; 

        this.game = game;
        this.msecPerMove = msecPerMove;
        this.numGames = numGames;
        this.p1ClassFileName = p1ClassFileName;
        this.p2ClassFileName = p2ClassFileName;

        this.numSeedMoves = numRandMoves;
        this.startingBoard = newBoard(numSeedMoves);

        if (p1ClassFileName == null) {
            this.p1ClassFileName = defaultPlayer;
        }
        if (p2ClassFileName == null) {
            this.p2ClassFileName = defaultPlayer;
        }

		//initialize the board
		setting = new setUp("Connect-n Board Initialization", this, rows, cols, consecutivePieces);
		setting.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setting.show();
		 
    }

	//when click on "Start Game" in setting GUI
	//close setting GUI, show ghe ConnectN GUI
	public void startGame() 
	{
		//close setting GUI
		setting.setVisible(false);

        // Open game GUI.
        gui = new ConnectNGUI("Connect-n",this,rows,cols,consecutivePieces);
        gui.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		gui.show();
        newMatch();
	}

    private void updateGUI() {
        gui.updateMaxTime(msecPerMove);
        gui.updateGame(gameNum,numGames,numSeedMoves);
        gui.updateTurn(whoseTurn);
        gui.updateMove(moveNum);
        gui.updateNames(
            p1.name() + " [" + p1.getClass().getName() + "]",
            p2.name() + " [" + p2.getClass().getName() + "]");
        gui.updateBoard(board);
        gui.updateScore(p1GamesWon,p2GamesWon,p1Points,p2Points);
        if (state != STATE_MATCHOVER) {
            status(((whoseTurn==1)?p1:p2).name() + "'s turn"
                   + " (Player #" + whoseTurn + ")");
        }
        // update scores
    }

	private void updateSettingGUI()  
	{
		setting.updateRows(rows);
		setting.updateCols(cols);
		setting.updateConnected(consecutivePieces);
	}

    public void status (String status) {
        System.err.println(status);
        gui.updateStatus(status);
    }

    public boolean isPaused() { 
        return state == STATE_PAUSED;
    }

    private ConnectNBoard newBoard(int nmoves) {
        ConnectNBoard b = new ConnectNBoard(rows,cols, consecutivePieces); 
        java.util.Random rand = new java.util.Random();
        for (int i=0; i<nmoves; i++) {
            int col = 0;
            do { col = rand.nextInt(b.numCols());
            } while (!b.isValidMove(col));
            b.move(col,1+(i%2));
        }
        return b;
    }
    
    public void initBoardAndPlayers() {
        // Initialize the board.
        //assert (numSeedMoves%2)==0;
        if ((gameNum%2)==0) {
            startingBoard.reverse();
        } else {
            startingBoard = newBoard(numSeedMoves);
        }
        board = new ConnectNBoard (startingBoard);
        // Initialize the players.
        {
            Player p1Prev = p1;
            String p1ClassPrev = p1ClassFileName;
             try {
                p1 = getPlayer(p1ClassFileName);
            }
            catch (Exception e) {
                status("Failed to initialize player #1");
                p1 = p1Prev;
                p1ClassFileName = p1ClassPrev;
            }
        }
        {
            Player p2Prev = p2;
            String p2ClassPrev = p2ClassFileName;
            try {
                p2 = getPlayer(p2ClassFileName);
            }
            catch (Exception e) {
                status("Failed to initialize player #2");
                p2 = p2Prev;
                p2ClassFileName = p2ClassPrev;
            }
        }
        if ((p1 instanceof HumanPlayer) && p1HumanName != null) {
            ((HumanPlayer)p1).setName(p1HumanName);
        }
        if ((p2 instanceof HumanPlayer) && p2HumanName != null) {
            ((HumanPlayer)p2).setName(p2HumanName);
        }
        p1.init(1,msecPerMove,rows,cols);
        p2.init(2,msecPerMove,rows,cols);
    }

    /** Reset things for a new match.
	 */
    public void newMatch() {
        state = STATE_PAUSED;
        newGame(true);
    }

    /** Reset things for a new game.
	 */
    public void newGame (boolean newMatch) {
       // assert newMatch || gameNum < numGames;
        prevMoveCol = -1;
        gameNum = newMatch ? 1 : (gameNum+1);
        moveNum = 1;
        whoseTurn = 2-(gameNum%2);
        System.err.println("gameNum="+gameNum+" whoseTurn="+whoseTurn);
        p1Points = p2Points = 0;
        if (newMatch) {
            p1GamesWon = p2GamesWon = 0;
        }
        initBoardAndPlayers();
        updateGUI();
    }

    public void changeP1 (String p1ClassFileName, String p1HumanName) {
		System.out.println("p1ClassFileName=" + p1ClassFileName);
        if (p1ClassFileName == null) return;
        status ("Changing player #1 to: " + p1ClassFileName);
        this.p1ClassFileName = p1ClassFileName;
        this.p1HumanName = p1HumanName;
        newMatch();
    }

    public void changeP2 (String p2ClassFileName, String p2HumanName) {
        if (p2ClassFileName == null) return;
        status ("Changing player #2 to: " + p2ClassFileName);
        this.p2ClassFileName = p2ClassFileName;
        this.p2HumanName = p2HumanName;
        newMatch();
    }

    public void changeNGames (int ngames) {
        if (this.numGames == ngames) return;
        if (ngames < 1) return;
        status ("Changing #games to: " + ngames);
        this.numGames = ngames;
        newMatch();
    }

  /*  public void changeMatchPlay (boolean matchPlay) {
        if (matchPlay == this.matchPlay) return;
        this.matchPlay = matchPlay;
        status ("Match play now: " + (matchPlay?"on":"off"));
        // Make sure the number of games is even.
        if ((numGames%2)==1) numGames++;
        newMatch();
    }*/

    public void changeNumRandMoves (int nmoves) {
        if (nmoves == this.numSeedMoves) return;
        if (nmoves < 0) return;
        if (nmoves > rows*cols) return;
        if ((nmoves%2)==1) nmoves++; // must be even
        status ("Changing #rand moves to: " + nmoves);
        this.numSeedMoves = nmoves;
        newMatch();
    }

    public void changeMaxMoveTime (int maxMoveTime) {
        if (this.msecPerMove == maxMoveTime) return;
        if (maxMoveTime < 0) return;
        status ("Changing max move time to: " + maxMoveTime);
        this.msecPerMove = maxMoveTime;
        newMatch();
    }

	//change Setting GUI, 
	public void changeRows (int rows) 
	{

		if(rows > 3 && rows < 10)
		{
			this.rows = rows;
			System.out.println ("Changing board rows to: " + rows);
			updateSettingGUI();// update setting GUI
		}
		else System.out.println ("Invalid setting value to rows: " + rows);
	}

	public void changeCols (int cols) 
	{
		if(cols > 3 && cols < 10)
		{
			this.cols = cols;
			System.out.println ("Changing board cols to: " + cols);
			updateSettingGUI();// update setting GUI
		}
		else System.out.println ("Invalid setting value to cols: " + cols);
	}

	public void changePiecesNum (int piecesNum) 
	{
		if(piecesNum >1 && piecesNum < 7 && piecesNum < cols && piecesNum < rows)
		{
			this.consecutivePieces = piecesNum;
			System.out.println ("Changing Connect-n winning length to: " + consecutivePieces );
			updateSettingGUI();// update setting GUI
		}
		else System.out.println ("Invalid setting value to Connect-n length: " + piecesNum);
	}


    public void pause() 
	{
        if (state != STATE_PLAYING) return;
        state = STATE_PAUSED;
    }

    public void moveHuman (int row, int col) {
        if (state == STATE_MATCHOVER) return;
        if (whoseTurn==1 && !(p1 instanceof HumanPlayer)) return;
        if (whoseTurn==2 && !(p2 instanceof HumanPlayer)) return;
        if (!board.isValidMove(col)) return;
        doMove(col);
        if (state == STATE_PLAYING) {
            gui.pressStepButton();
        }
        updateGUI();
    }

    /** Return the id (>0) of the winner for normal connect-n play.
	 *  Return 0 if there is no winner.
	 *  Return -1 if there is more than 1 winner.
	 */
    public int calcWinner (ConnectNBoard board) {
        final int rows = board.numRows();
        final int cols = board.numCols();
		final int consecutivePieces = board.numConnected(); 

        int winner = 0,k;
        // Look for horizontal connect-Ns.
        for (int r=0; r<rows; r++) {
 			for (int c=0; c<=cols-consecutivePieces; c++){
                int id = board.get(r,c);
                if (id==0) continue;
				for(k=1;k<consecutivePieces;k++) 
				{
					if (board.get(r,c+k) != id) break;
 				}
				if(k==consecutivePieces)
				{
					if (winner != 0 && winner != id) return -1;
					winner = id;
				}
            }
        }
        // Look for vertical connect-Ns.
        for (int c=0; c<cols; c++) {
            for (int r=0; r<=rows-consecutivePieces; r++) { 
                int id = board.get(r,c);
                if (id==0) continue;
				for( k=1;k<consecutivePieces;k++) 
				{
					if (board.get(r+k,c) != id) break;
 				}
				if(k==consecutivePieces)
				{
					if (winner != 0 && winner != id) return -1;
					winner = id;
				}            
			}
        }
        // Look for diagonal connect-Ns.
        for (int c=0; c<=cols-consecutivePieces; c++) { 
            for (int r=0; r<=rows-consecutivePieces; r++) { 
                int id = board.get(r,c);
                if (id==0) continue;
				for(  k=1;k<consecutivePieces;k++) 
				{
					if (board.get(r+k,c+k) != id) continue;
 				}
				if(k==consecutivePieces)
				{
					if (winner != 0 && winner != id) return -1;
					winner = id;
				}            
			}
        }
        for (int c=0; c<=cols-consecutivePieces; c++) { 
            for (int r=rows-1; r>=consecutivePieces-1; r--) { 
                int id = board.get(r,c);
                if (id==0) continue;
				for(  k=1;k<consecutivePieces;k++) 
				{
					if (board.get(r-k,c+k) != id) continue;
 				}
				if(k==consecutivePieces)
				{
					if (winner != 0 && winner != id) return -1;
					winner = id;
				}            
			}
        }
        return winner;
    }

    /** Return the number of connect-4s that player #id has.
	 */
    public int calcScore (ConnectNBoard board, int id) {
        final int rows = board.numRows();
        final int cols = board.numCols();
		final int consecutivePieces = board.numConnected(); 

        int score = 0, k;
        // Look for horizontal connect-4s.
        for (int r=0; r<rows; r++) {
            for (int c=0; c<=cols-consecutivePieces; c++) { 
				for(k=0;k<consecutivePieces;k++) 
				{
					if (board.get(r,c+k) != id) break;
 				}
				if(k==consecutivePieces) score++;
            }
        }
        // Look for vertical connect-4s.
        for (int c=0; c<cols; c++) {
            for (int r=0; r<=rows-consecutivePieces; r++) { 
				for( k=0;k<consecutivePieces;k++) 
				{
					if (board.get(r+k,c) != id) break;
 				}
  					if(k==consecutivePieces) score++;
               
            }
        }
        // Look for diagonal connect-4s.
        for (int c=0; c<=cols-consecutivePieces; c++) { 
            for (int r=0; r<=rows-consecutivePieces; r++) { 
				for( k=0;k<consecutivePieces;k++) 
				{
					if (board.get(r+k,c+k) != id) break;
 				}
  					if(k==consecutivePieces) score++;
              
            }
        }
        for (int c=0; c<=cols-consecutivePieces; c++) { 
            for (int r=rows-1; r>=consecutivePieces-1; r--) { 
				for( k=0;k<consecutivePieces;k++) 
				{
					if (board.get(r-k,c+k) != id) break;
 				}
 					if(k==consecutivePieces) score++;
                
            }
        }
        return score;
    }

    private void doMove (int col) {
        System.err.println("doMove");
 
        status (((whoseTurn==1)?p1:p2).name()
                + " (Player #" + whoseTurn + ")"
                + " moves to column #" + col);
        board.move(col,whoseTurn);

        // Check for a winner.
        boolean gameWon = false;
        if (game.equals("first")) {
            int winner = calcWinner(board);
            if (winner>0 || board.isFull()) {
                declareWinner(winner);
                gameWon = true;
            }
        } else if (game.equals("most")) {
            p1Points = calcScore(board,1);
            p2Points = calcScore(board,2);
            if (board.isFull()) {
                if (p1Points == p2Points) 
                    declareWinner(0);
                else 
                    declareWinner((p1Points > p2Points) ? 1 : 2);
                gameWon = true;
            }
        } else {
            throw new Error ("bug: game="+game);
        }

        if (!gameWon) {
            whoseTurn = (whoseTurn==1) ? 2 : 1;
            prevMoveCol = col;
            moveNum++;
        }
    }

    public void declareWinner (int id) {
 
        String msg = null;
        switch (id) {
            case 0: 
                msg = null; 
                break;
            case 1:
                p1GamesWon++;
                msg = p1.name() + " (Player #1)"; 
                break;
            case 2:
                p2GamesWon++;
                msg = p2.name() + " (Player #2)"; 
                break;
            default: 
                throw new Error ("bug: winner="+id);
        }
        updateGUI();
        gui.announceGameWinner(msg,gameNum,numGames);

        if (gameNum == numGames) {
            state = STATE_MATCHOVER;
            if (p1GamesWon > p2GamesWon) {
                gui.announceMatchWinner(
                    p1.name() + " (Player #1)",
                    p1GamesWon, p2GamesWon);
            } else {
                gui.announceMatchWinner(
                    p2.name() + " (Player #2)",
                    p2GamesWon, p1GamesWon);
            }
        }

        if (gameNum < numGames) {
            newGame(false);
        }
    }

    public void step() {
        if (state == STATE_MATCHOVER) return;
        if (whoseTurn==1 && (p1 instanceof HumanPlayer)) return;
        if (whoseTurn==2 && (p2 instanceof HumanPlayer)) return;
        if (board.isFull()) return;
                
        // Let the next player calculate their next move.
         Player[] players = { null, p1, p2 };
        int moveCol = calcMove(
            board,players[whoseTurn],prevMoveCol,msecPerMove);

        // Make sure the move is valid.  If it is not, then
        // the other player wins.  
        if (!board.isValidMove(moveCol)) {
            status("Player #" + whoseTurn + " (" 
                   + players[whoseTurn].name() 
                   + ") made an illegal move.");
            int winner = (whoseTurn==1) ? 2 : 1;
            declareWinner(winner);
        } 
        else {
            // Make the move.
            doMove(moveCol);
            // Do it this way instead of calling step() so that the
            // user can interact with the UI during play.
        }

        if (state == STATE_PLAYING) {
            gui.pressStepButton();
        }

        updateGUI();
    }

    public void play() {
        if (state != STATE_PAUSED) return;
        state = STATE_PLAYING;
        gui.pressStepButton();
    }

    /** Given the name of a class that implemements the Player interface,
	 *  return an instance of that class.  Dynamic loading is cool!
	 */
    private Player getPlayer (String classFileName) throws Exception 
	{

		Class c; 
		try 
		{
				c = Class.forName(classFileName); 
		}
		catch( ClassNotFoundException inCNFE ) 
		{
			System.out.println( "Class not found" + classFileName);
			throw new Exception();
		}

         return (Player) c.newInstance();
    }
    
    /** Let player #i calculate their next move.  The player is not
	 *  permitted to spend more than msecAllowed time to do this
	 *  calculation.  If the player takes too much time, then we
	 *  have it make an illegal move (which forfeits the game).
	 */
    private int calcMove (
        ConnectNBoard board, Player player, int prevMoveCol, int msecPerMove) {
        // Start up the player in a separate thread so we are
        // protected from its exceptions and infinite loops.
        PlayerThread pt = new PlayerThread(
            player, board, prevMoveCol);
        pt.start();
        long startTime = System.currentTimeMillis();

        Thread.currentThread().yield();

        // Let the player think for a while.
        int msecAllowed = msecPerMove * 120 / 100;
        int msecPerSpin = msecAllowed / 100;
        msecPerSpin = Math.max(1,msecPerSpin);
        while (true) {
            // If the player is done thinking, then stop spinning.
            if (!pt.isAlive()) break;
            // If the max allowed time has elapsed, then stop spinning.
            if (System.currentTimeMillis()-startTime > msecAllowed) break;
            // Otherwise, spin.
            try { Thread.currentThread().sleep(msecPerSpin);
            } catch (InterruptedException e) {}
        }
        
        // Notify the player thread that time is up.  If the player
        // is already done calculating its next move, then this has
        // no effect.  If the player is still working, then its
        // next call to checkTime() will cause it to stop.
        player.timeUp();

        // Give the player thread time to stop.
        for (int i = 0; i < 5; i++) {
            Thread.currentThread().yield();
            if (pt.isAlive()) {
                try { Thread.currentThread().sleep(100);
                } catch (InterruptedException e) {}
            }
        }

        // If the player thread has still not exited, then disqualify it by
        // returning an invalid move; otherwise, return whatever move it
        // calculated.
        if (pt.isAlive()) {
            status("Player #" + whoseTurn + " (" + player.name() 
                   + ") is disqualified for taking too much time.");
            return -1;
        } else {
            return player.getMove();
        }
    }
}
