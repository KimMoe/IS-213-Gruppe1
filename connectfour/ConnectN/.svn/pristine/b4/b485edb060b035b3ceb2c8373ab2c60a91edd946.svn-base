package is207.connectn.handin.glenn;

import is207.connectn.strategy.Strategy;

import java.util.Random;
import java.util.Stack;



public abstract class GGAbstractStrategy extends Strategy
{
    protected int[][] board;
    protected int me;
    protected int[] colHeight;
    protected Stack<Integer> moves = new Stack<Integer>();
    final boolean ALWAYSOVERWRITESELECTEDMOVE = false;
    protected boolean debug = false;

    private static Random rand = new Random();
    final int MEINROW1 = 2;
    final int MEINROW2 = 4;
    final int MEINROW3 = 8;
    final int MEINROW3MIDDLE = 16;
    final int OPPINROW1 = 2;
    final int OPPINROW2 = 4;
    final int OPPINROW3 = 8;
    final int OPPINROW3MIDDLE = 16;

    protected int score16, score8, score4, score2;
    private int[] inRowVert;
    protected int[][] inRowDiagUp;
    //private HashSet<RowCol> inRowDiagUpPath = new HashSet<RowCol>();
    protected int[][] inRowDiagDown;

    @Override
    public Integer call() {
        // Am I the first or second player? Am I making the first move?
        if (getTurns() == 0) {
            me = lastMove == -1 ? 1 : 2;
            // Just quickly return one of the middle columns.
            board = new int[rows][cols];
            colHeight = new int[cols];
            selectedMove = rand.nextInt(rows - 2) + 1;
            updateInternalBoard(selectedMove, me);
            return selectedMove;
        }
        updateInternalBoard(lastMove, getOpponent());
        selectedMove = runLogic();
        updateInternalBoard(selectedMove, me); // TODO Må kunne settes tidligere, og overskrives i tilfelle tråden blir terminert.
        return selectedMove;
    }

    protected abstract int runLogic();

    public void resetStrategy() {
        board = new int[rows][cols];
        colHeight = new int[cols];
        moves = new Stack<Integer>();
    }

    /**
     * Just to check if my game state is same as GameState class.
     * Stole method from GameState class.
     */
    protected void printState() {
        System.out.print("+");
        for (int col = 0; col < cols; col++)
            System.out.print("-");
        System.out.println("+");
        for (int row = rows - 1; row >= 0; row--) {
            System.out.print("|");
            for (int col = 0; col < cols; col++) {
                int p = board[row][col];
                if (0 == p)
                    System.out.print(".");
                else if (p == 1)
                    System.out.print("O");
                else if (p == 2)
                    System.out.print("X");
                else
                    System.out.print("?");
            }
            System.out.println("|");
        }
        System.out.print("+");
        for (int col = 0; col < cols; col++)
            System.out.print("-");
        System.out.println("+");
        System.out.flush();
    }

    /**
     * Does this chip belong to the player?
     *
     * @param r	row
     * @param c	col
     * @param p	player
     *
     * @return
     */
    protected boolean ownedBy(int r, int c, int p) {
        return board[r][c] == p;
    }

    protected int getTurns() {
        return moves.size();
    }

    protected void updateInternalBoard(int move, int p) {
        moves.push(move);
        board[getColHeight(move)][move] = p;
        colHeight[move]++;
    }

    protected String getMoves() {
        String result = null;
        for (int i : moves) {
            if (result == null)
                result = String.valueOf(i);
            else
                result += String.valueOf(i);
        }
        return result;
    }

    protected int getOpponent() {
        return me == 1 ? 2 : 1;
    }

    protected int getWhosTurn() {
        return getTurns() % 2 == 0 ? 2 : 1;
    }

    protected int getColHeight(int column) {
        return colHeight[column];
    }

    public BestMove getBestMove(int player) {
        inRowVert = new int[cols];
        inRowDiagUp = new int[rows][cols];
        inRowDiagDown = new int[rows][cols];
        for (int i = 0; i < cols; i++)
            inRowVert[i] = 0;
        //int me = getOpponent();
        BestMove bestMove = new BestMove();
        if (player == me) {
            score16 = MEINROW3MIDDLE;
            score8 = MEINROW3;
            score4 = MEINROW2;
            score2 = MEINROW1;
        }
        else {
            score16 = OPPINROW3MIDDLE;
            score8 = OPPINROW3;
            score4 = OPPINROW2;
            score2 = OPPINROW1;
        }
        int p = player, inRowHor;
        for (int r = 0; r < rows; r++) {
            inRowHor = 0;
            for (int c = 0; c < cols; c++) {
                /*
                 * TODO dette funket ikke noe bra, kommentert vekk
                 *
                 *
                 * if (c >= cols-2) {
                 * continue; // Ikke vits i å sjekke kanten om igjen
                 * }
                 */

                if (ownedBy(r, c, p)) {
                    // Vi har en brikke som er vår
                    inRowHor++;
                    inRowVert[c]++;

                    // Diagonalt oppover
                    inRowDiagUp(r, c);
                    // Diagonalt nedover
                    inRowDiagDown(r, c);
                }
                else if (ownedBy(r, c, 0)) {// Sjekk om plassen er tom
                    if (inRowVert[c] != 0)
                        evaluateVerticalPos(r, c, p, inRowVert[c], bestMove);
                    evaluateHorizPos(r, c, p, inRowHor, bestMove);
                    int diagUp = getInRowDiagUp(r, c);
                    int diagDown = getInRowDiagDown(r, c);
                    if (diagUp != 0)
                        evaluateDiagUpPos(r, c, p, diagUp, bestMove);
                    if (diagDown != 0)
                        evaluateDiagDownPos(r, c, p, diagDown, bestMove);
        			//testEvaluatePos(r, c, p, inRowHor, bestMove);
                    //testEvaluatePos(c, r, p, 0, bestMove);
                    // Hvis dette er motstanderens brikke, er vi jo doomed
                    // når det kommer til horisontale wins på denne raden.
                    inRowHor = 0;
                    inRowVert[c] = 0;

                }
                else if (ownedBy(r, c, getOpponent())) {
                    inRowHor = 0;
                    inRowVert[c] = 0;
                }

            }
        }
        // Ingen bra plass funnet, gi en random col 1 i score.
        if (bestMove.getBestCol() == -1) {
            Random r = new Random();
            int ra = r.nextInt(validMoves.get(validMoves.size() - 1));
            bestMove.addToScore(ra, 1);
        }
        return bestMove;
    }

    protected void evaluateDiagDownPos(int r, int c, int p, int inRow,
                                       BestMove bestMove) {
        switch (inRow) {
        case 3:
            //System.out.printf("Row %d Col %d", r, c);
            if (getColHeight(c) == r)
                bestMove.addToScore(c, score16);
            else
                bestMove.addToScore(c, score4); // Ikke høyt nok, men kan kanskje bygge opp?
            break;

        case 2:
            if (r < rows - 1 && c > 0 && ownedBy(r + 1, c - 1, 0)) {
                if (getColHeight(c) == r) {
                    if (r < 5 && r > 2 && c < 5 && c > 2) {
                        bestMove.addToScore(c, score8);
                    }

                    else {
                        bestMove.addToScore(c, score4);
                    }
                }
                else
                    bestMove.addToScore(c, score2); // Ikke høyt nok, men kan kanskje bygge opp?

            }
            break;
        case 1:
            if (c > 2 && r < rows - 2 && (ownedBy(r + 1, c - 1, 0) && ownedBy(r + 2, c - 2, 0) && getColHeight(c) == r)) {
                bestMove.addToScore(c, score2);
            }

        }

    }

    /**
     * Returnerer hvor mange brikker man har på rad diagonalt mot
     * venstre
     * FØR posisjonen man gir
     *
     * @param r	row
     * @param c	col
     *
     * @return	Antall på rad
     */
    private int getInRowDiagUp(int r, int c) {
        if (r > 0 && c > 0) return inRowDiagUp[r - 1][c - 1];
        else return 0;
    }

    /**
     * Returnerer hvor mange brikker man har på rad diagonalt mot
     * høyre
     * FØR posisjonen man gir
     *
     * @param r	row
     * @param c	col
     *
     * @return	Antall på rad
     */
    private int getInRowDiagDown(int r, int c) {
        if (r > 0 && c < cols - 1) return inRowDiagDown[r - 1][c + 1];
        else return 0;
    }

    /**
     * Øk antall på rad diagonalt oppover
     *
     * @param r	row
     * @param c	col
     */
    protected void inRowDiagUp(int r, int c) {
        int prev = 0;
        if (r != 0 && c != 0)
            prev = inRowDiagUp[r - 1][c - 1];
        inRowDiagUp[r][c] = prev + 1;
    }

    /**
     * Øk antall på rad diagonalt nedover
     *
     * @param r	row
     * @param c	col
     */
    protected void inRowDiagDown(int r, int c) {
        if (r == 0) {
            inRowDiagDown[r][c] = 1;
        }
        else if (r > 0 && c < cols - 1) {
            int prev = inRowDiagDown[r - 1][c + 1];
            inRowDiagDown[r][c] = prev + 1;
        }
    }

    protected void evaluateDiagUpPos(int r, int c, int p, int inRow, BestMove bestMove) {
        //System.out.printf("Row %d Col %d, in row %d", r, c, inRow);
        switch (inRow) {
        case 3:
            //System.out.printf("Row %d Col %d", r, c);
            if (r < rows && c < cols) {
                if (getColHeight(c) == r)
                    bestMove.addToScore(c, score16);
                else
                    bestMove.addToScore(c, score4); // Ikke høyt nok, men kan kanskje bygge opp?
            }
            break;

        case 2:
            if (r < rows - 1 && c < cols - 1 && ownedBy(r + 1, c + 1, 0)) {
                if (getColHeight(c) == r) {
                    if (r < 5 && r > 2 && c < 5 && c > 2) {
                        bestMove.addToScore(c, score8);
                    }

                    else {
                        bestMove.addToScore(c, score4);
                    }
                }
                else
                    bestMove.addToScore(c, score2); // Ikke høyt nok, men kan kanskje bygge opp?

            }
            break;
        case 1:
            if (r < rows - 2 && c < cols - 2 && ownedBy(r + 1, c + 1, 0) && ownedBy(r + 2, c + 2, 0) && getColHeight(c) == r) {
                bestMove.addToScore(c, score2);
            }

        }
    }

    protected void evaluateVerticalPos(int r, int c, int p, int inRow, BestMove bestMove) {

        switch (inRow) {
        case 3:
            if (r < rows - 1 && ownedBy(r + 1, c, 0))
                bestMove.addToScore(c, score16);
            break;
        case 2:
            if (r < rows - 2 && ownedBy(r + 1, c, 0)) {
                if (r < 5 && r > 2 && c < 5 && c > 2) {
                    bestMove.addToScore(c, score8);
                }

                else {
                    bestMove.addToScore(c, score4);
                }
            }
            break;
        case 1:
            if (r < rows - 3 && ownedBy(r + 1, c, 0))
                bestMove.addToScore(c, score2);
            break;
        case 0:
            break;

        }
    }

    protected void evaluateHorizPos(int r, int c, int p, int inRow, BestMove bestMove) {
        switch (inRow) {
        case 3:
            // Vi har 3 på rad, men et hull her.
            bestMove.addToScore(c, score16);
            break;
        case 2:
            if (!(c < rows - 2))
                break;
			// Vi har 2 på rad, men et hull her, og vi er ikke så
            // langt ut på kanten at det ikke er mulig å få 4pårad
            if (c < cols - 2) {
				// Neste brikker er vår, og vår posisjon "c"
                // er et hull
                if (ownedBy(r, c + 1, 1))
                    bestMove.addToScore(c, score16);
                // Neste brikke er tom.
                if (ownedBy(r, c + 1, 0))
                    bestMove.addToScore(c, score4);

            }
            else {
				// Foretrekker midten for høyere sjans til å gjøre
                // no bra
                if (c < 5 && c > 2) {
                    bestMove.addToScore(c, score8);
                }
                else {
                    bestMove.addToScore(c, score4);
                }
            }
            break;
        case 1:
            if (!(c < rows - 3))
                break;
            // Er de to neste mine eller?
            if ((c < cols - 2) && ownedBy(r, c + 1, p) && ownedBy(r, c + 2, p)) {
                // Hull, men de to neste er mine.
                bestMove.addToScore(c, score16);
            }

            // Kanskje jeg har 1 her, ett hull, og så 1 eller fler?
            else if ((c < cols - 1) && ownedBy(r, c + 1, p)) {
				// Ja, se det.. her har vi faktisk mulighet
                // til å få 3 på rad...

                // Sjekk for gøy om vi kan få 4?
                if ((cols < cols - 2) && ownedBy(r, c + 2, p))
                    bestMove.addToScore(c, score16);

                else {
					// Foretrekker midten for høyere sjans til å gjøre
                    // no bra
                    if (c < 5 && c > 2) {
                        bestMove.addToScore(c, score8);
                    }
                    else {
                        bestMove.addToScore(c, score4);
                    }
                }
            }
            else if (getColHeight(c) == r) {
                bestMove.addToScore(c, score2);
            }
            break;
        case 0:
			// Vi har ingen på rad, men kanskje neste posisjon
            // er en av våre brikker? Da kan dette potensielt
            // være et hull som lager 2,3 eller 4 på rad.

            // Ja, vi har tre
            if ((c < cols - 3)
                    && ownedBy(r, c + 1, p)
                    && ownedBy(r, c + 2, p)
                    && ownedBy(r, c + 3, p))
                bestMove.addToScore(c, score16);

            // Ja, vi har to
            else if ((c < cols - 2)
                    && ownedBy(r, c + 1, p)
                    && ownedBy(r, c + 2, p)) {
                // Gir flere poeng til midten av brettet.
                if (c < 5 && c > 2) {
                    bestMove.addToScore(c, score8);
                }

                else {
                    bestMove.addToScore(c, score4);
                }
            }

            // Ja, en har vi hvertfall
            else if ((c < cols - 1) && getColHeight(c) == r && ownedBy(r, c + 1, p))
                bestMove.addToScore(c, score2);
            break;
        }
    }



    class BestMove
    {
        int[] eval = new int[cols];
        int bestCol = -1;
        int bestScore = -1;

        public void addToScore(int col, int points) {
            eval[col] += points;
            if (debug)
                System.out.println("Adding " + points + " to col " + col);
            if (points > bestScore) {
                if (getWhosTurn() == me || ALWAYSOVERWRITESELECTEDMOVE) {
                    selectedMove = col;
                }

                bestScore = points;
                bestCol = col;
            }
        }

        /**
         * @return the bestCol
         */
        public int getBestCol() {
            return bestCol;
        }

        /**
         * @return the bestScore
         */
        public int getBestScore() {
            return bestScore;
        }

        /**
         * @param bestCol the bestCol to set
         */
        public void setBestCol(int bestCol) {
            this.bestCol = bestCol;
        }

        /**
         * @param bestScore the bestScore to set
         */
        public void setBestScore(int bestScore) {
            this.bestScore = bestScore;
        }

    }
}
