package is207.connectn.handin.glenn;

import java.io.File;
import java.util.HashSet;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;



public class GGThreadedLearningDefensiveStrategy extends GGAbstractStrategy implements Callable<Integer>
{

    final boolean ALWAYSOVERWRITESELECTEDMOVE = false;
    HashSet<String> winList = new HashSet<String>();
    boolean foundLearnedMove;
    boolean debug = true;

    final int MEINROW1 = 2;
    final int MEINROW2 = 4;
    final int MEINROW3 = 10;
    final int MEINROW3MIDDLE = 20;
    final int OPPINROW1 = 1;
    final int OPPINROW2 = 8;
    final int OPPINROW3 = 8;
    final int OPPINROW3MIDDLE = 15;

    public GGThreadedLearningDefensiveStrategy() {
        winList = loadDataFile(me);
    }

    private HashSet<String> loadDataFile(int player) {
        Scanner data = null;
        HashSet<String> list = new HashSet<String>();
        String filename = player == 1 ? "GGL1.dat" : "GGL2.dat";
        try {
            data = new Scanner(new File(filename));
        }
        catch (Exception e) {
        }
        if (data != null) {
            while (data.hasNext()) {
                list.add(data.next());
            }
            data.close();
        }
        return list;

    }

    protected int runLogic() {
        ExecutorService service = Executors.newFixedThreadPool(3);
        Future<Integer[]> learned = null;
        if (getTurns() > 3) {
            learned = service.submit(new FindLearnedMove(winList, getMoves()));
        }
        Future<Integer[]> myBest = service.submit(new FindBestPlayerMove(rows, cols, me, board, colHeight, validMoves, MEINROW1, MEINROW2, MEINROW3, MEINROW3MIDDLE));
        Future<Integer[]> oppBest = service.submit(new FindBestPlayerMove(rows, cols, getOpponent(), board, colHeight, validMoves, OPPINROW1, OPPINROW2, OPPINROW3, OPPINROW3MIDDLE));

        try {
            service.awaitTermination(450, TimeUnit.MILLISECONDS);
        }
        catch (InterruptedException e1) {
			// TODO Auto-generated catch block
            //e1.printStackTrace();
        }

        int oppBestScore = 0;
        int oppBestCol = 0;
        int myBestScore = 0;
        int myBestCol = 0;
        int learnedScore = 0;
        int learnedCol = 0;

        try {
            oppBestScore = oppBest.get()[1];
            oppBestCol = oppBest.get()[0];
            myBestScore = myBest.get()[1];
            myBestCol = myBest.get()[0];
            if (learned != null) {
                learnedScore = learned.get()[1];
                learnedCol = learned.get()[0];
            }
        }
        catch (InterruptedException e1) {
            // TODO Auto-generated catch block
//			e1.printStackTrace();
        }
        catch (ExecutionException e1) {
            // TODO Auto-generated catch block
//			e1.printStackTrace();
        }

        if (learnedScore == 0) { // Ikke funnet noe data p√• dette brettet
            if (myBestScore != 16 && myBestScore <= oppBestScore) {
                selectedMove = oppBestCol;
                if (debug)
                    System.out.printf("Chose opponents best move at col %d with score %d\n", oppBestCol, oppBestScore);
            }
            else {
                selectedMove = myBestCol;
                if (debug)
                    System.out.printf("Chose my own best move at col %d with score %d\n", myBestCol, myBestScore);
            }
        }
        else {
            selectedMove = learnedCol;
            if (debug)
                System.out.printf("Chose a pre-learned best move at col %d with score %d\n", learnedCol, learnedScore);
        }
        // Learn
        if (myBestScore >= 16) {
    		// Winning combination found... learn
            // Don't want to wait, execute in thread.
            (new Thread(new Wisdom(me, getMoves() + selectedMove, winList))).start();
        }
        return selectedMove;
    }

}
