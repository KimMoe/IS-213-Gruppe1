package is207.connectn.game.strategy.minimax;

import is207.connectn.game.GameParams;
import is207.connectn.game.strategy.Strategy;
import java.util.ArrayList;



/**
 * This is NegaMax with alpha-beta pruning
 *
 * @author evenal
 */
public class NegaScout extends Strategy
{
    private static final int ME = 1;
    private static final int HIM = -1;
    Board board;
    boolean haveMoved = false;

    @Override
    public void setup(GameParams params) {
        super.setup(params);
        board = new Board(rows, cols);
    }

    @Override
    public Integer call() {
        // update board
        if (haveMoved) board.doMove(ME, selectedMove);
        if (lastMove >= 0) board.doMove(HIM, lastMove);

        int depth = 5;

        Result res = negaScout(ME, depth,
                Integer.MIN_VALUE, Integer.MAX_VALUE);
        selectedMove = res.move;
        return selectedMove;
    }

    private Result negaScout(int colour, int depth,
                             int alpha, int beta) {
        if (depth == 0)
            return new Result(-1, colour * eval());

        int bestValue = Integer.MIN_VALUE;
        int bestMove = -1;
        ArrayList<Integer> moves = board.getLegalMoves();
        if (moves.isEmpty())
            return new Result(-1, colour * eval());

        for (int m : moves) {
            board.doMove(m, depth - 1);
            Result res = negaScout(-colour, depth, -beta, -alpha);
            int val = -res.value;
            if (val > bestValue) {
                bestValue = val;
                bestMove = m;

            }
            board.undoMove();
            if (val > alpha) {
                alpha = val;
                if (alpha > beta) {
                    break;
                }
            }
        }
        return new Result(bestMove, bestValue);

    }

    private int eval() {
        int myPoints = 0;
        int oppPoints = 0;

        for (int r = 0; r < rows; r++)
            for (int c = 0; c < cols; c++) {
                myPoints += countPts(r, c, ME);
                oppPoints += countPts(r, c, HIM);
            }
        board.logState("Eval -> ", myPoints - oppPoints);
        return myPoints - oppPoints;
    }

    private int countPts(int r, int c, int player) {
        if (board.state[r][c] == HIM) return 0;
        int sum = countPts(r, c, player, 1, 0);
        sum += countPts(r, c, player, 1, 1);
        sum += countPts(r, c, player, 0, 1);
        sum += countPts(r, c, player, -1, 1);
        sum += countPts(r, c, player, -1, 0);
        sum += countPts(r, c, player, -1, -1);
        sum += countPts(r, c, player, 0, -1);
        sum += countPts(r, c, player, 1, -1);
        return sum;
    }

    private int countPts(int r, int c, int p, int dr, int dc) {
        int sum = 0;
        for (int i = 0; i < nConn; i++) {
            int v = board.state[r + i * dr][c + i * dc];
            if (v == p) sum += 5;
            else if (v == 0) sum += 1;
            else return 0;
        }
        return sum;
    }



    private class Result
    {
        public int move;
        public int value;

        public Result(int move, int value) {
            this.move = move;
            this.value = value;
        }
    }
}
