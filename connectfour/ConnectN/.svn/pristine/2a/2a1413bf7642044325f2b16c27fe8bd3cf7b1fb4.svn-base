package is207.connectn.game;

import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;



/**
 * Base class for Strategy implementation. Strategy objects must keep
 * track of the game state, and select a move as a response to the
 * opponents last move.
 *
 * @author evenal
 */
public abstract class Strategy implements Callable<Integer> {

    String name;
    protected int cols;
    protected int rows;
    protected int timeout;
    protected TimeUnit timeUnit;
    protected int selectedMove;
    protected int lastMove;


    /**
     * setup() is called before the game starts, to provide the
     * strategy about the game configuration. This method is called to
     * provide the strategy with information. It can not be used to
     * change the game configuration
     *
     * @param cols     the number of columns
     * @param rows     the number of rows
     * @param timeout  the time available to select a move
     * @param timeUnit the unit of timeaout
     */
    public void setup(int cols, int rows,
                      int timeout, TimeUnit timeUnit) {
        this.cols = cols;
        this.rows = rows;
        this.timeout = timeout;
        this.timeUnit = timeUnit;
    }


    /**
     * @return the total number of timeUnits available for selecting a
     *         move. NOTE: This is not the remaining time. It is the
     *         responsibility of the strategy to keep track of how
     *         much time is left.
     */
    public int getTimeout() {
        return timeout;
    }


    public TimeUnit getTimeUnit() {
        return timeUnit;
    }


    public String getName() {
        return name;
    }


    /**
     * Decide the next move. The move is the index of the column to
     * drop a disk in. The disk will drop to the lowest empty cell in
     * that column.
     *
     * @return the next move
     */
    public abstract Integer call();


    /**
     * Called from Game (indirectly - through Player.selectMove()) to
     * compute the next move to make. This method is final to prevent
     * cheating. All the work of actually selecting a move should
     * happen in call().
     *
     * @param lastMove the last move made by the opponent. The value
     *                 is the index of the column the opponent dropped
     *                 a disk into. If this strategy is deciding the
     *                 first move of the game, i.e. the opponent
     *                 hasn't made a move yet, the parameter value
     *                 will be -1
     *
     * @return the next move
     */
    public final int selectMove(int lastMove) {
        this.lastMove = lastMove;
        return call();
    }

}
