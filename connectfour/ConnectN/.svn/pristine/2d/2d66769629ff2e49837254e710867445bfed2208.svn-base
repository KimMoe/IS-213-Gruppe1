package is207.connectn.game.strategy.minimax;

import is207.connectn.game.GameParams;
import is207.connectn.game.strategy.Strategy;
import java.util.ArrayList;
import java.util.Scanner;



/**
 * This is NegaMax with alpha-beta pruning
 *
 * @author evenal
 */
public class NegaScout extends Strategy
{
    private static final int ME = 1;
    private static final int HIM = -1;
    Board board;
    int lookAhead = 0;



    @Override
    public void setup(GameParams params) {
        super.setup(params);
        board = new Board(rows, cols);
        selectedMove = lastMove = -1;
    }

    @Override
    public Integer call() {
        // update board
        if (selectedMove >= 0) board.doMove(selectedMove, ME);
        if (lastMove >= 0) board.doMove(lastMove, HIM);

        for ( lookAhead =3; lookAhead<10; lookAhead++) {
            Result res = negaScout(ME, lookAhead,
                Integer.MIN_VALUE, Integer.MAX_VALUE);
            selectedMove = res.move;
        }
        return selectedMove;
    }

    private Result negaScout(int player, int depth,
                             int alpha, int beta) {
        if (depth == 0)
            return new Result(-1, player * eval());

        int bestValue = Integer.MIN_VALUE;
        int bestMove = -1;
        ArrayList<Integer> moves = board.getLegalMoves();
        if (moves.isEmpty())
            return new Result(-1, player * eval());

        for (int m : moves) {
            board.doMove(m, player);
            Result res = negaScout(-player, depth-1, -beta, -alpha);
            int val = -res.value;
            if (depth == lookAhead) System.err.println("Move "+m+" --> "+val);
            if (val > bestValue) {
                bestValue = val;
                bestMove = m;
            }
            board.undoMove();
            if (val > alpha) {
                alpha = val;
                if (alpha > beta) {
                    board.logState("alfa="+alpha+" beta="+beta+" cut ", val);
                    break;
                }
            }
        }
        return new Result(bestMove, bestValue);

    }

    private int eval() {
        int myPoints = 0;
        int oppPoints = 0;

        for (int r = 0; r < rows; r++)
            for (int c = 0; c < cols; c++) {
                myPoints += countPts(r, c, ME);
                oppPoints += countPts(r, c, HIM);
            }
        board.logState("Eval -> ", myPoints - oppPoints);
        return myPoints - oppPoints;
    }

    private int countPts(int r, int c, int player) {
        if (board.state[r][c] != ME) return 0;
        int sum = countPts(r, c, player, 1, 0);
        sum += countPts(r, c, player, 1, 1);
        sum += countPts(r, c, player, 0, 1);
        sum += countPts(r, c, player, -1, 1);
        sum += countPts(r, c, player, -1, 0);
        sum += countPts(r, c, player, -1, -1);
        sum += countPts(r, c, player, 0, -1);
        sum += countPts(r, c, player, 1, -1);
        return sum;
    }

    private int countPts(int r, int c, int p, int dr, int dc) {
        int seq = 0;
        int total = 0;
        boolean broken = false;

        for (int i = 0; i < nConn; i++) {
            int tr = r+i*dr;
            int tc = c+i*dc;
            if (tr >=0 && tr < rows && tc >= 0 && tc < cols) {
                int v = board.state[r + i * dr][c + i * dc];
                if (v == p) {
                    total++;
                    if (! broken) seq++;
                }
                else if (v == 0) broken = true;
                else return 0;
            }
        }
        if (seq == nConn) return 1000;
        else if (seq == nConn - 1) return 100;
        else return total;
    }



    private class Result
    {
        public int move;
        public int value;

        public Result(int move, int value) {
            this.move = move;
            this.value = value;
        }
    }


    public static void main(String[] args) {

        NegaScout strat = new NegaScout();
        strat.setup(new GameParams());
        Scanner in = new Scanner(System.in);

        while (true) {
            System.out.print("Move: ");
            int move = in.nextInt();
            if (move < 0)
                System.exit(0);
            System.out.println("you chose " + move);

            strat.prepare(move, null);
            strat.call();
            System.out.println("Computer chose " + strat.getSelectedMove());
        }
    }
}
