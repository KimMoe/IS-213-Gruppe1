package is207.connectn.game;

import is207.connectn.game.GameManager.GameListener;
import java.util.ArrayList;



/**
 * Represents a single game between two players. The primary
 * responsibility of this class is to the keep track of whose
 * turn it is, and let that player insert a disk when makeMove()
 * is called.
 * <p>
 * Then the board (game state) is updated and checked for the winning
 * condition.
 *
 * @author evenal
 */
public class Game
{

    public final GameParams gameParams;
    private GameState board;
    boolean gameOver;
    private Player winner;

    int numMoves;
    int lastMove;
    Player[] players;
    ArrayList<GameListener> listeners;

    /**
     * Create a new game
     *
     * @param gameParams the game parameters
     * @param player1 the first player (who makes the first move)
     * @param player2 the second player
     */
    public Game(GameParams gameParams, Player player1, Player player2) {
        this.gameParams = gameParams;
        board = new GameState(gameParams);
        players = new Player[]{player1, player2};
        numMoves = 0;
        lastMove = -1;
        winner = null;
    }

    public Player[] getPlayers() {
        return players;
    }

    /**
     * Check whether the game is over
     *
     * @return true if the game is over, false otherwise
     */
    public boolean isGameOver() {
        return gameOver;
    }

    /**
     * Get the winner. Calling this method only makes sense when the
     * game is
     * over
     *
     * @return the winning player, or null if it's a draw
     */
    public Player getWinner() {
        return winner;
    }


    public GameState getGameState() {
        return board;
    }

    /**
     * Let the next player make a move, update the game state and
     * check if the
     * player won the game with his move.
     */
    public void makeMove() throws GameException {
        if (gameOver) {
            System.out.println("How did we get here???????");
            return;
        }
        Player p = players[numMoves % 2];
        try {
            ArrayList<Integer> moves = board.getValidMoves();
            if (moves.size() == 0) { // check for full board
                System.out.println("Game over - board is full");
                gameOver = true;
                winner = null;
                return;
            }
            lastMove = p.selectMove(this, lastMove, moves);
            board.add(lastMove, p);
            board.printState();

            if (hasWon(p, lastMove)) {
                gameOver = true;
                System.out.format("" + p.getName() + " won\n");
                winner = p;
                return;
            }
            numMoves++;
        }
        catch (Exception e) {
            gameOver = true;
            if (players[0] == p) winner = players[1];
            else winner = players[0];
            e.printStackTrace();
            throw new GameException("Player " + p.getName() + " threw an Exception!", e, p);
        }
    }

    /**
     * Check whether the last move won the game
     *
     * @param p the player who made the last move
     * @param col the column he inserted a disc in
     * @return true if the player won, false if he didn't
     */
    private boolean hasWon(Player p, int col) {
        int row = board.getHeight(col) - 1;
        // We do not have to check the whole board
        // The last disc inserted must be one the four
        // connected discs, any other connected fours
        // should have been discovered when made.
        // horizontal
        if (connected(p, row, col, 0, 1)) {
            return true;
        }
        //vertical
        if (connected(p, row, col, 1, 0)) {
            return true;
        }
        // diagonals
        if (connected(p, row, col, 1, 1)) {
            return true;
        }
        if (connected(p, row, col, 1, -1)) {
            return true;
        }
        return false;
    }

    private boolean connected(Player p, int row, int col, int dr, int dc) {
        int count = 0;

        //move backward while p owns the pieces and
        // we're inside the board
        int r = row;
        int c = col;
        while (owns(p, r, c)) {
            r = r - dr;
            c = c - dc;
        }
        // moved one step too far
        r = r + dr;
        c = c + dc;

        while (owns(p, r, c)) {
            count++;
            r = r + dr;
            c = c + dc;
        }
        return count >= gameParams.getConnLen();
    }

    /**
     * return true if p owns cell r,c
     */
    private boolean owns(Player p, int r, int c) {
        if (r < 0) {
            return false;
        }
        if (r >= gameParams.getRows()) {
            return false;
        }
        if (c < 0) {
            return false;
        }
        if (c >= gameParams.getCols()) {
            return false;
        }
        if (board.get(r, c) != p) {
            return false;
        }
        return true;
    }
}
