package is207.connectn.game.strategy.minimax;

import is207.connectn.strategy.Board;
import is207.connectn.game.GameParams;
import is207.connectn.strategy.Strategy;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;



/**
 *
 * @author evenal
 */
public class NegaMaxStrategy extends Strategy
{

    private final EvalResult MIN_RESULT = new EvalResult(Integer.MIN_VALUE);
    public static final int FREE = 0;
    public static final int ME = 1;
    public static final int OPPONENT = -1;
    private static final int MAX_DEPTH = 5;

    Random random = new Random();

    Board board;
    Evaluator evaluator;

    
    public void setup(GameParams params) {
        super.setup(params);
        board = new Board(rows, cols);
        evaluator = new Evaluator();
    }

    public Integer call() {
        if (lastMove >= 0)
            board.doMove(lastMove, OPPONENT);
        EvalResult result = negamax(MAX_DEPTH, ME, new ArrayList<>());
        selectedMove = result.path.get(result.path.size() - 1);
        return selectedMove;
    }

    public EvalResult negamax(int depth,
                              int player,
                              ArrayList<Integer> path) {
        EvalResult bestResult = MIN_RESULT;

        if (depth == 0) {
            bestResult = new EvalResult(player * evaluator.eval());
        }
        else {
            ArrayList<Integer> moves = board.getLegalMoves();
            // if no available moves, the board is full which is a draw
            // no need to analyze
            if (moves.size() == 0) {
                bestResult = new EvalResult(0);
            }
            else {
                for (int c : moves) {
                    EvalResult result = tryMove(depth, c, player, path);
                    if (result.value >= bestResult.value) {
                        bestResult = result;
                        bestResult.path.add(c);
                    }
                }
            }
        }
        return bestResult;
    }

    EvalResult tryMove(int depth, int c, int player, ArrayList<Integer> path) {
        Board prev = board.clone();

        int r = board.h[c];
        board.doMove(c, player);
        path.add(c);
        EvalResult result = negamax(depth - 1, -player, path);
        result.value = -result.value;
        board.undoMove();
        path.remove(path.size() - 1);
        return result;
    }



    private class EvalResult
    {

        int value;
        ArrayList<Integer> path;

        public EvalResult(int value) {
            this.value = value;
            path = new ArrayList<>();
        }

    }



    private class Evaluator
    {

        // summary of the situation - the number of places where
        // arrayindex pieces are missing to win
        int[] myOpportunities = new int[3];
        int[] oppOpportunities = new int[3];

        // disk counts
        int mine, opps, free;

        public Evaluator() {
        }

        public int eval() {
            myOpportunities = new int[3];
            oppOpportunities = new int[3];

            // check for horizontal lines
            for (int r = 0; r < rows; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r][c + i]);
                    analyzeCounts();
                }

            // check for vertical  lines
            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c]);
                    analyzeCounts();
                }

            // check for diagonal  lines
            for (int r = 0; r < rows - nConn; r++)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++)
                        count(board.state[r + i][c + i]);
                    analyzeCounts();
                }
            for (int r = rows - 1; r >= nConn - 1; r--)
                for (int c = 0; c < cols - nConn; c++) {
                    mine = opps = free = 0;
                    for (int i = 0; i < nConn; i++) {
                        int ri = r - i;
                        int ci = c + i;
                        count(board.state[ri][ci]);
                    }
                    analyzeCounts();
                }

            int retval = 0;
            for (int i = 0; i < 3; i++) {
                retval = 10 * retval
                        + myOpportunities[i]
                        - oppOpportunities[i];
            }
            board.logState("Returning ", retval);
            return retval;
        }

        private void count(int cellVal) {
            switch (cellVal) {
            case ME:
                mine++;
                break;
            case OPPONENT:
                opps++;
                break;
            case FREE:
                free++;
                break;
            }
        }

        /**
         * Check if the game is one, or if the player is missing only
         * one or two pieces to win. The result is added to the
         * opportunities arrays
         */
        private void analyzeCounts() {
            for (int i = 0; i < 3; i++) {
                if (free == i && opps == nConn - i) {
                    oppOpportunities[i]++;
                }
                if (free == i && mine == nConn - i) {
                    myOpportunities[i]++;
                }
            }
        }
    }

    public static void main(String[] args) {

        NegaMaxStrategy strat = new NegaMaxStrategy();
        strat.setup(new GameParams());
        Scanner in = new Scanner(System.in);

        while (true) {
            System.out.print("Move: ");
            int move = in.nextInt();
            if (move < 0)
                System.exit(0);
            System.out.println("you chose " + move);

            strat.prepare(move, null);
            strat.call();
            System.out.println("Computer chose " + strat.getSelectedMove());
        }
    }
}
