package is207.connectn.game;

import java.util.ArrayList;
import java.util.LinkedList;
import javax.swing.JOptionPane;



/**
 * Represents a single game between two players. The primary
 * responsibility of this class is to let the players make a move in
 * turn, make sure they do not exceed the timelimit for deciding the
 * move, and to determine the winner.
 *
 * @author evenal
 */
public class Game {

    private GameParams gameParams;
    private GameState board;
    boolean gameOver;
    private Player winner;

    int numMoves;
    int lastMove;
    LinkedList<Player> queue;


    /**
     * Create a game
     *
     * @param timeLimit The amount of time a player is allowed to
     *                  "think" before making a move
     * @param rows      size of board
     * @param cols
     * @param conn_len  number of pieces needed in line to win
     * @param player1   first player, starts the game
     * @param player2   second player
     */
    public Game(GameParams gameParams, Player player1, Player player2) {

        board = new GameState(gameParams);
        queue = new LinkedList<>();
        queue.addLast(player1);
        queue.addLast(player2);
        numMoves = 0;
        lastMove = -1;
        winner = null;
    }


    public void addGameStateListener(GameStateListener l) {
        board.addGameStateListener(l);
    }


    public Player run() {
        System.out.println("Starting game...");
        winner = null;

        while (!isGameOver()) {
            try {
                winner = makeMove();
            }
            catch (GameException ge) {
                ge.printStackTrace();
                JOptionPane.showMessageDialog(null, ge);
            }
        }
        return winner;
    }


    private boolean isGameOver() {
        return gameOver;
    }


    public Player getWinner() {
        return winner;
    }


    /**
     * Let the first player in the queue make a move
     *
     * @return true if the player has won
     */
    public Player makeMove() throws GameException {
        Player p = queue.removeFirst();
        try {
            ArrayList<Integer> moves = board.getValidMoves();
            if (moves.size() == 0) { // check for full board
                gameOver = true;
                return null;
            }
            lastMove = p.selectMove(lastMove, moves);
            board.add(lastMove, p);
            System.out.format("%s chose col %d\n", p.getName(), lastMove);
            if (hasConnectedN(p, lastMove)) {
                gameOver = true;
                System.out.format("" + p.getName() + " won");
                return p;
            }
            queue.addLast(p);
        }
        catch (Exception e) {
            throw new GameException(null, e, p);
        }
        return null;
    }


    private boolean hasConnectedN(Player p, int col) {
        int row = board.getHeight(col) - 1;
        // we only have to check whether the last piece
        // mad a winning series of pieces
        // horizontal
        if (connected(p, row, col, 0, 1))
            return true;
        //vertical
        if (connected(p, row, col, 1, 0))
            return true;
        // diagonals
        if (connected(p, row, col, 1, 1))
            return true;
        if (connected(p, row, col, 1, -1))
            return true;
        return false;
    }


    private boolean connected(Player p, int row, int col, int dr, int dc) {
        int count = 0;
        int minCount = gameParams.getConnLen();

        for (int i = -minCount + 1; i < minCount - 1; i++) {
            int r = row + i * dr;
            int c = col + i * dc;
            if (r >= 0 && r < gameParams.getRows()
                    && c >= 0 && r < gameParams.getCols()
                    && board.get(r, c) == p)
                count++;
        }
        return count >= minCount;
    }
}
