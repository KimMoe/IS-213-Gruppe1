package is207.connectn.handin.glenn;

import java.util.Random;
import java.util.ArrayList;
import java.util.concurrent.Callable;



public class FindBestPlayerMove implements Callable<Integer[]>
{

    protected int[] inRowVert;
    protected int[][] inRowDiagUp;
    protected int[][] inRowDiagDown;
    protected int cols;
    protected int rows;
    private int score2;
    private int score4;
    private int score8;
    private int score16;
    private ArrayList<Integer> validMoves;
    protected int[][] board;
    protected int me;
    protected int[] colHeight;
    protected BestMove bestMove;

    public FindBestPlayerMove(int rows, int cols, int player, int[][] board, int[] colHeight, ArrayList<Integer> validMoves, int score2, int score4, int score8, int score16) {

        this.rows = rows;
        this.cols = cols;
        this.me = player;
        this.score2 = score2;
        this.score4 = score4;
        this.score8 = score8;
        this.score16 = score16;
        this.board = board;
        this.colHeight = colHeight;
        this.validMoves = validMoves;

    }

    public int getBestCol() {
        return bestMove.getBestCol();
    }

    @Override
    public Integer[] call() {
        bestMove = getBestMove(me);
        Integer[] result = new Integer[] {bestMove.getBestCol(), bestMove.getBestScore()};
//		result[0] = bestMove.getBestCol();
//		result[1] = bestMove.getBestScore();
        return result;
    }

    public BestMove getBestMove(int player) {
        inRowVert = new int[cols];
        inRowDiagUp = new int[rows][cols];
        inRowDiagDown = new int[rows][cols];
        for (int i = 0; i < cols; i++)
            inRowVert[i] = 0;
        //int me = getOpponent();
        BestMove bestMove = new BestMove();
        int p = player, inRowHor;
        for (int r = 0; r < rows; r++) {
            inRowHor = 0;
            for (int c = 0; c < cols; c++) {

                if (ownedBy(r, c, p)) {
                    // Vi har en brikke som er vår
                    inRowHor++;
                    inRowVert[c]++;

                    // Diagonalt oppover
                    inRowDiagUp(r, c);
                    // Diagonalt nedover
                    inRowDiagDown(r, c);
                }
                else if (ownedBy(r, c, 0)) {// Sjekk om plassen er tom
                    if (inRowVert[c] != 0)
                        evaluateVerticalPos(r, c, p, inRowVert[c], bestMove);
                    evaluateHorizPos(r, c, p, inRowHor, bestMove);
                    int diagUp = getInRowDiagUp(r, c);
                    int diagDown = getInRowDiagDown(r, c);
                    if (diagUp != 0)
                        evaluateDiagUpPos(r, c, p, diagUp, bestMove);
                    if (diagDown != 0)
                        evaluateDiagDownPos(r, c, p, diagDown, bestMove);
        			//testEvaluatePos(r, c, p, inRowHor, bestMove);
                    //testEvaluatePos(c, r, p, 0, bestMove);
                    // Hvis dette er motstanderens brikke, er vi jo doomed
                    // når det kommer til horisontale wins på denne raden.
                    inRowHor = 0;
                    inRowVert[c] = 0;

                }
                else if (ownedBy(r, c, getOpponent())) {
                    inRowHor = 0;
                    inRowVert[c] = 0;
                }

            }
        }
        // Ingen bra plass funnet, gi en random col 1 i score.
        if (bestMove.getBestCol() == -1) {
            Random r = new Random();
            int ra = r.nextInt(validMoves.get(validMoves.size() - 1));
            bestMove.addToScore(ra, 1);
        }
        return bestMove;
    }

    protected void evaluateDiagDownPos(int r, int c, int p, int inRow,
                                       BestMove bestMove) {
        switch (inRow) {
        case 3:
            //System.out.printf("Row %d Col %d", r, c);
            if (getColHeight(c) == r)
                bestMove.addToScore(c, score16);
            else
                bestMove.addToScore(c, score4); // Ikke høyt nok, men kan kanskje bygge opp?
            break;

        case 2:
            if (r < rows - 1 && c > 0 && ownedBy(r + 1, c - 1, 0)) {
                if (getColHeight(c) == r) {
                    if (r < 5 && r > 2 && c < 5 && c > 2) {
                        bestMove.addToScore(c, score8);
                    }

                    else {
                        bestMove.addToScore(c, score4);
                    }
                }
                else
                    bestMove.addToScore(c, score2); // Ikke høyt nok, men kan kanskje bygge opp?

            }
            break;
        case 1:
            if (c > 2 && r < rows - 2 && (ownedBy(r + 1, c - 1, 0) && ownedBy(r + 2, c - 2, 0) && getColHeight(c) == r)) {
                bestMove.addToScore(c, score2);
            }

        }

    }

    /**
     * Returnerer hvor mange brikker man har på rad diagonalt mot
     * venstre
     * FØR posisjonen man gir
     *
     * @param r	row
     * @param c	col
     *
     * @return	Antall på rad
     */
    private int getInRowDiagUp(int r, int c) {
        if (r > 0 && c > 0) return inRowDiagUp[r - 1][c - 1];
        else return 0;
    }

    /**
     * Returnerer hvor mange brikker man har på rad diagonalt mot
     * høyre
     * FØR posisjonen man gir
     *
     * @param r	row
     * @param c	col
     *
     * @return	Antall på rad
     */
    private int getInRowDiagDown(int r, int c) {
        if (r > 0 && c < cols - 1) return inRowDiagDown[r - 1][c + 1];
        else return 0;
    }

    /**
     * Øk antall på rad diagonalt oppover
     *
     * @param r	row
     * @param c	col
     */
    protected void inRowDiagUp(int r, int c) {
        int prev = 0;
        if (r != 0 && c != 0)
            prev = inRowDiagUp[r - 1][c - 1];
        inRowDiagUp[r][c] = prev + 1;
    }

    /**
     * Øk antall på rad diagonalt nedover
     *
     * @param r	row
     * @param c	col
     */
    protected void inRowDiagDown(int r, int c) {
        if (r == 0) {
            inRowDiagDown[r][c] = 1;
        }
        else if (r > 0 && c < cols - 1) {
            int prev = inRowDiagDown[r - 1][c + 1];
            inRowDiagDown[r][c] = prev + 1;
        }
    }

    protected void evaluateDiagUpPos(int r, int c, int p, int inRow, BestMove bestMove) {
        //System.out.printf("Row %d Col %d, in row %d", r, c, inRow);
        switch (inRow) {
        case 3:
            //System.out.printf("Row %d Col %d", r, c);
            if (r < rows && c < cols) {
                if (getColHeight(c) == r)
                    bestMove.addToScore(c, score16);
                else
                    bestMove.addToScore(c, score4); // Ikke høyt nok, men kan kanskje bygge opp?
            }
            break;

        case 2:
            if (r < rows - 1 && c < cols - 1 && ownedBy(r + 1, c + 1, 0)) {
                if (getColHeight(c) == r) {
                    if (r < 5 && r > 2 && c < 5 && c > 2) {
                        bestMove.addToScore(c, score8);
                    }

                    else {
                        bestMove.addToScore(c, score4);
                    }
                }
                else
                    bestMove.addToScore(c, score2); // Ikke høyt nok, men kan kanskje bygge opp?

            }
            break;
        case 1:
            if (r < rows - 2 && c < cols - 2 && ownedBy(r + 1, c + 1, 0) && ownedBy(r + 2, c + 2, 0) && getColHeight(c) == r) {
                bestMove.addToScore(c, score2);
            }

        }
    }

    protected void evaluateVerticalPos(int r, int c, int p, int inRow, BestMove bestMove) {

        switch (inRow) {
        case 3:
            if (r < rows - 1 && ownedBy(r + 1, c, 0))
                bestMove.addToScore(c, score16);
            break;
        case 2:
            if (r < rows - 2 && ownedBy(r + 1, c, 0)) {
                if (r < 5 && r > 2 && c < 5 && c > 2) {
                    bestMove.addToScore(c, score8);
                }

                else {
                    bestMove.addToScore(c, score4);
                }
            }
            break;
        case 1:
            if (r < rows - 3 && ownedBy(r + 1, c, 0))
                bestMove.addToScore(c, score2);
            break;
        case 0:
            break;

        }
    }

    protected void evaluateHorizPos(int r, int c, int p, int inRow, BestMove bestMove) {
        switch (inRow) {
        case 3:
            // Vi har 3 på rad, men et hull her.
            bestMove.addToScore(c, score16);
            break;
        case 2:
            if (!(c < rows - 2))
                break;
			// Vi har 2 på rad, men et hull her, og vi er ikke så
            // langt ut på kanten at det ikke er mulig å få 4pårad
            if (c < cols - 2) {
				// Neste brikker er vår, og vår posisjon "c"
                // er et hull
                if (ownedBy(r, c + 1, 1))
                    bestMove.addToScore(c, score16);
                // Neste brikke er tom.
                if (ownedBy(r, c + 1, 0))
                    bestMove.addToScore(c, score4);

            }
            else {
				// Foretrekker midten for høyere sjans til å gjøre
                // no bra
                if (c < 5 && c > 2) {
                    bestMove.addToScore(c, score8);
                }
                else {
                    bestMove.addToScore(c, score4);
                }
            }
            break;
        case 1:
            if (!(c < rows - 3))
                break;
            // Er de to neste mine eller?
            if ((c < cols - 2) && ownedBy(r, c + 1, p) && ownedBy(r, c + 2, p)) {
                // Hull, men de to neste er mine.
                bestMove.addToScore(c, score16);
            }

            // Kanskje jeg har 1 her, ett hull, og så 1 eller fler?
            else if ((c < cols - 1) && ownedBy(r, c + 1, p)) {
				// Ja, se det.. her har vi faktisk mulighet
                // til å få 3 på rad...

                // Sjekk for gøy om vi kan få 4?
                if ((cols < cols - 2) && ownedBy(r, c + 2, p))
                    bestMove.addToScore(c, score16);

                else {
					// Foretrekker midten for høyere sjans til å gjøre
                    // no bra
                    if (c < 5 && c > 2) {
                        bestMove.addToScore(c, score8);
                    }
                    else {
                        bestMove.addToScore(c, score4);
                    }
                }
            }
            else if (getColHeight(c) == r) {
                bestMove.addToScore(c, score2);
            }
            break;
        case 0:
			// Vi har ingen på rad, men kanskje neste posisjon
            // er en av våre brikker? Da kan dette potensielt
            // være et hull som lager 2,3 eller 4 på rad.

            // Ja, vi har tre
            if ((c < cols - 3)
                    && ownedBy(r, c + 1, p)
                    && ownedBy(r, c + 2, p)
                    && ownedBy(r, c + 3, p))
                bestMove.addToScore(c, score16);

            // Ja, vi har to
            else if ((c < cols - 2)
                    && ownedBy(r, c + 1, p)
                    && ownedBy(r, c + 2, p)) {
                // Gir flere poeng til midten av brettet.
                if (c < 5 && c > 2) {
                    bestMove.addToScore(c, score8);
                }

                else {
                    bestMove.addToScore(c, score4);
                }
            }

            // Ja, en har vi hvertfall
            else if ((c < cols - 1) && getColHeight(c) == r && ownedBy(r, c + 1, p))
                bestMove.addToScore(c, score2);
            break;
        }
    }

    protected boolean ownedBy(int r, int c, int p) {
        return board[r][c] == p;
    }

    protected int getOpponent() {
        return me == 1 ? 2 : 1;
    }

    protected int getColHeight(int column) {
        return colHeight[column];
    }



    class BestMove
    {
        int[] eval = new int[cols];
        int bestCol = -1;
        int bestScore = -1;
        private boolean debug = false;

        public void addToScore(int col, int points) {
            eval[col] += points;
            if (debug)
                System.out.println("Adding " + points + " to col " + col);
            if (points > bestScore) {

                bestScore = points;
                bestCol = col;
            }
        }

        /**
         * @return the bestCol
         */
        public int getBestCol() {
            return bestCol;
        }

        /**
         * @return the bestScore
         */
        public int getBestScore() {
            return bestScore;
        }

        /**
         * @param bestCol the bestCol to set
         */
        public void setBestCol(int bestCol) {
            this.bestCol = bestCol;
        }

        /**
         * @param bestScore the bestScore to set
         */
        public void setBestScore(int bestScore) {
            this.bestScore = bestScore;
        }

    }
}
