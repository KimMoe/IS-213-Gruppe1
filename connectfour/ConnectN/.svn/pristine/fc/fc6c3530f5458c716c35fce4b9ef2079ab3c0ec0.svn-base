package connectN.ctN;

import connectN.players.*;

// A Connect-N board class.

public class ConnectNBoard
{
    private int rows, cols;
	private int connectedNum; 
    private int[] cells;
    private int totalCount;
    private int[] colCounts;

    /** Default configuration is 6 rows and 7 columns.
	 */
    public ConnectNBoard () {
        this(6,7,4); 
    }

    /** Construct a board of custom size.
	 */
    public ConnectNBoard (int rows, int cols, int connectedNum) { 
        this.rows = rows;
        this.cols = cols;
		this.connectedNum = connectedNum; 
  
        this.cells = new int [rows*cols];
        this.totalCount = 0;
        this.colCounts = new int [cols];
    }

    /** Create a copy of an existing board.
	 */
    public ConnectNBoard (ConnectNBoard that) {
        this(that.numRows(),that.numCols(), that.numConnected()); 
 
        System.arraycopy(that.cells,0,this.cells,0,rows*cols);
        System.arraycopy(that.colCounts,0,this.colCounts,0,cols);
        this.totalCount = that.totalCount;
    }

	/** Return the number of rows
	 */
    public int numRows() { 
        return rows; 
    }

	/** Return the number of columns
	 */
    public int numCols() { 
        return cols; 
    }

	/** Return the number of connected dices for a win line,  
	 */
	public int numConnected() 
	{ 
		return connectedNum; 
	}

	/** Return the number of cells which is row*column
	 */
    public int numCells() { 
        return cells.length;
    }

	/** Return the number of occupied cells
	 */
    public int numOccupiedCells() { 
        return totalCount; 
    }

	/** Return the number of unoccupied cells
	 */
    public int numEmptyCells() { 
        return numCells() - numOccupiedCells();
    }

	/** Return true if all cells are occupied, otherwise return false
	 */
    public boolean isFull() { 
        return numOccupiedCells() == numCells();
    }

	/** Return true if the specified column col is full, 
	 *  otherwise return false
	 */
    public boolean isColumnFull (int col) { 
        return colCounts[col] == rows; 
    }

	/** Return true if the specified cell (rom, col) is occupied,
	 *  otherwise return false
	 */
    public boolean isOccupied (int row, int col) { 
        return get(row,col) > 0;
    }

    /** Return values:
	 *    0 = unoccupied
	 *   1 = occupied by player #1
	 *    2 = occupied by player #2
	 */
    public int get (int row, int col) { 
        if (row<0 || row>=rows || col<0 || col>=cols) {
            throw new IndexOutOfBoundsException(
                "row=" + row + " col=" + col);
        }
        return cells[row*cols+col];
    }

    /** This method is private on purpose.  It is too dangerous to
	 * export, since it could be used to put the board into an invalid
	 *  configuration.  All modifications to the board should be made
	 *  with the move() and unmove() methods.
	 */
    private void set (int row, int col, int id) { 
        if (id < 0 || id > 2) {
            throw new IllegalArgumentException("id="+id);
        }
        if (row<0 || row>=rows || col<0 || col>=cols) {
            throw new IndexOutOfBoundsException(
                "row=" + row + " col=" + col);
        }
        cells[row*cols+col] = id;
    }

    /** Change all player#1 pieces to player#2, and vice versa.
	 */
    public void reverse() {
        for (int r=0; r<rows; r++) {
            for (int c=0; c<cols; c++) {
                int v = get(r,c);
                if (v!=0) set(r,c,3-v);
            }
        }
    }

	/** Return true if the column col is not full and within the specified range,
	 *  otherwise return false
	 */
    public boolean isValidMove (int col) {
        return (col>=0) && (col<cols) && !isColumnFull(col);
    }

	/** Make a move in column col for player id and update the total 
	 *  number of occupied cells 
	 */
    public void move (int col, int id) {
        if (id < 1 || id > 2) {
            throw new IllegalArgumentException("id="+id);
        }
        if (!isValidMove(col)) {
            throw new IllegalArgumentException(
                "invalid move: col="+col);
        }
        set(colCounts[col]++,col,id);
        totalCount++;
    }
    
	/** Remove a move from column col for player id and update 
	 *  the total number of occupied cells
	 */
    public void unmove (int col, int id) {
        if (id < 1 || id > 2) {
            throw new IllegalArgumentException("id="+id);
        }
        if (colCounts[col] == 0 || get(colCounts[col]-1,col) != id) { 
            throw new IllegalArgumentException(
                "invalid unmove: col="+col);
        }
        set(--colCounts[col],col,0);
        totalCount--;
    }
    
    public String toString() {
        StringBuffer s = new StringBuffer ((rows+2)*(cols+1));
        for (int c=0; c<cols+2; c++) s.append('-');
        s.append('\n');
        for (int r=rows-1; r>=0; r--) {
            s.append('|');
            for (int c=0; c<cols; c++) {
                s.append(get(r,c));
            }
            s.append("|\n");
        }
        for (int c=0; c<cols+2; c++) s.append('-');
        s.append('\n');
        return s.toString();
    }
}
